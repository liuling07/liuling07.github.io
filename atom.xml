<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[残剑博客]]></title>
  <subtitle><![CDATA[技术成长之路]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.liuling123.com/"/>
  <updated>2016-06-21T13:17:12.000Z</updated>
  <id>http://www.liuling123.com/</id>
  
  <author>
    <name><![CDATA[Lauren]]></name>
    <email><![CDATA[lauren.liuling@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Ubuntu下adb无法识别手机设备]]></title>
    <link href="http://www.liuling123.com/2016/06/ubuntu-adb-devices.html"/>
    <id>http://www.liuling123.com/2016/06/ubuntu-adb-devices.html</id>
    <published>2016-06-21T13:14:00.000Z</published>
    <updated>2016-06-21T13:17:12.000Z</updated>
    <content type="html"><![CDATA[<p>(1)首先使用lsusb命令，列出所有usb设备的VID、PID号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;liuling@liuling-PC:~$ lsusb&#10;&#10;Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub&#10;&#10;Bus 001 Device 014: ID 2b0e:1768  &#10;&#10;Bus 001 Device 004: ID 0461:0010 Primax Electronics, Ltd HP Keyboard&#10;&#10;Bus 001 Device 003: ID 03f0:094a Hewlett-Packard &#10;&#10;Bus 001 Device 009: ID 046d:c053 Logitech, Inc. Laser Mouse&#10;&#10;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#10;&#10;liuling@liuling-PC:~$</span><br></pre></td></tr></table></figure>
<p>其中Bus 001 Device 014: ID 2b0e:1768为我插入的手机设备，可以看出VID为2b0e，PID为1768。</p>
<p>(2)在用户的 home 目录下，寻找 .android 目录，如果没有就创建。在 .android 目录下新建一个文件，叫adb_usb.ini, 记住，后缀是 “ini” 哦；添加前面获得的 VID 到 adb_usb.ini 中，如 0xAAAA，注意要加上0x，因为是16进制的。</p>
<p>(3)在 shell 中 分别输入 adb kill-server, adb start-server, adb devices；若能看到 devices 列出，那么就成功了。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>(1)首先使用lsusb命令，列出所有usb设备的VID、PID号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;liuling@l]]>
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="linux" scheme="http://www.liuling123.com/tags/linux/"/>
    
      <category term="Linux" scheme="http://www.liuling123.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JNI与C/C++数据类型的转换]]></title>
    <link href="http://www.liuling123.com/2016/06/jni-type-change.html"/>
    <id>http://www.liuling123.com/2016/06/jni-type-change.html</id>
    <published>2016-06-21T12:52:00.000Z</published>
    <updated>2016-06-21T13:19:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5B57_u7B26_u6570_u7EC4_u4E0EjbyteArray"><a href="#u5B57_u7B26_u6570_u7EC4_u4E0EjbyteArray" class="headerlink" title="字符数组与jbyteArray"></a>字符数组与jbyteArray</h2><h4 id="jbyteArray_u8F6C_u5B57_u7B26_u6570_u7EC4"><a href="#jbyteArray_u8F6C_u5B57_u7B26_u6570_u7EC4" class="headerlink" title="jbyteArray转字符数组"></a>jbyteArray转字符数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int byteSize = (int) env-&#62;GetArrayLength(jbyteArrayData);  //jbyteArrayData&#26159;jbyteArray&#31867;&#22411;&#30340;&#25968;&#25454;&#10;unsigned char* data = new unsigned char[byteSize + 1];&#10;env-&#62;GetByteArrayRegion(jbyteArrayData, 0, byteSize, reinterpret_cast&#60;jbyte*&#62;(data));&#10;data[byteSize] = &#39;\0&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u6570_u7EC4_u8F6CjbyteArray"><a href="#u5B57_u7B26_u6570_u7EC4_u8F6CjbyteArray" class="headerlink" title="字符数组转jbyteArray"></a>字符数组转jbyteArray</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jbyte *jb =  (jbyte*) data;   //data&#26159;&#23383;&#31526;&#25968;&#32452;&#31867;&#22411;&#10;jbyteArray jarray = env-&#62;NewByteArray(byteSize);   //byteSize&#26159;&#23383;&#31526;&#25968;&#32452;&#22823;&#23567;&#10;env-&#62;SetByteArrayRegion(jarray, 0, byteSize, jb);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="u5B57_u7B26_u6570_u7EC4_u4E0Ejstring"><a href="#u5B57_u7B26_u6570_u7EC4_u4E0Ejstring" class="headerlink" title="字符数组与jstring"></a>字符数组与jstring</h2><h4 id="jstring_u8F6C_u5B57_u7B26_u6570_u7EC4"><a href="#jstring_u8F6C_u5B57_u7B26_u6570_u7EC4" class="headerlink" title="jstring转字符数组"></a>jstring转字符数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* JstringToChar(JNIEnv* env, jstring jstr) &#123;&#10;&#9;if(jstr == NULL) &#123;&#10;&#9;&#9;return NULL;&#10;&#9;&#125;&#10;&#9;char* rtn = NULL;&#10;&#9;jclass clsstring = env-&#62;FindClass(&#34;java/lang/String&#34;);&#10;&#9;jstring strencode = env-&#62;NewStringUTF(&#34;utf-8&#34;);&#10;&#9;jmethodID mid = env-&#62;GetMethodID(clsstring, &#34;getBytes&#34;,&#10;&#9;&#9;&#9;&#34;(Ljava/lang/String;)[B&#34;);&#10;&#9;jbyteArray barr = (jbyteArray) env-&#62;CallObjectMethod(jstr, mid, strencode);&#10;&#9;jsize alen = env-&#62;GetArrayLength(barr);&#10;&#9;jbyte* ba = env-&#62;GetByteArrayElements(barr, JNI_FALSE);&#10;&#9;if (alen &#62; 0) &#123;&#10;&#9;&#9;rtn = (char*) malloc(alen + 1);&#10;&#9;&#9;memcpy(rtn, ba, alen);&#10;&#9;&#9;rtn[alen] = 0;&#10;&#9;&#125;&#10;&#9;env-&#62;ReleaseByteArrayElements(barr, ba, 0);&#10;&#9;return rtn;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u6570_u7EC4_u8F6Cjstring"><a href="#u5B57_u7B26_u6570_u7EC4_u8F6Cjstring" class="headerlink" title="字符数组转jstring"></a>字符数组转jstring</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstring StrtoJstring(JNIEnv* env, const char* pat)&#10;&#123;&#10;&#9;jclass strClass = env-&#62;FindClass(&#34;java/lang/String&#34;);&#10;&#9;jmethodID ctorID = env-&#62;GetMethodID(strClass, &#34;&#60;init&#62;&#34;, &#34;([BLjava/lang/String;)V&#34;);&#10;&#9;jbyteArray bytes = env-&#62;NewByteArray(strlen(pat));&#10;&#9;env-&#62;SetByteArrayRegion(bytes, 0, strlen(pat), (jbyte*)pat);&#10;&#9;jstring encoding = env-&#62;NewStringUTF(&#34;utf-8&#34;);&#10;&#9;return (jstring)env-&#62;NewObject(strClass, ctorID, bytes, encoding);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接使用NewStringUTF方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstring jstr = env-&#62;NewStringUTF(str);</span><br></pre></td></tr></table></figure>
<h2 id="int_u4E0Ejint"><a href="#int_u4E0Ejint" class="headerlink" title="int与jint"></a>int与jint</h2><p>jint与int的互转都可以直接使用强转，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jint i = (jint) 10;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5B57_u7B26_u6570_u7EC4_u4E0EjbyteArray"><a href="#u5B57_u7B26_u6570_u7EC4_u4E0EjbyteArray" class="headerlink" title="字符数组与jbyteArray"></a>字符数组与jbyteArray</h2><h4 id="jbyteArray_u8F6C_u5B57_u7B26_u6570_u7EC4"><a href="#jbyteArray_u8F6C_u5B57_u7B26_u6570_u7EC4" class="headerlink" title="jbyteArray转字符数组"></a>jbyteArray转字符数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int byteSize = (int) env-&#62;GetArrayLength(jbyteArrayData);  //jbyteArrayData&#26159;jbyteArray&#31867;&#22411;&#30340;&#25968;&#25454;&#10;unsigned char* data = new unsigned char[byteSize + 1];&#10;env-&#62;GetByteArrayRegion(jbyteArrayData, 0, byteSize, reinterpret_cast&#60;jbyte*&#62;(data));&#10;data[byteSize] = &#39;\0&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u6570_u7EC4_u8F6CjbyteArray"><a href="#u5B57_u7B26_u6570_u7EC4_u8F6CjbyteArray" class="headerlink" title="字符数组转jbyteArray"></a>字符数组转jbyteArray</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jbyte *jb =  (jbyte*) data;   //data&#26159;&#23383;&#31526;&#25968;&#32452;&#31867;&#22411;&#10;jbyteArray jarray = env-&#62;NewByteArray(byteSize);   //byteSize&#26159;&#23383;&#31526;&#25968;&#32452;&#22823;&#23567;&#10;env-&#62;SetByteArrayRegion(jarray, 0, byteSize, jb);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="jni" scheme="http://www.liuling123.com/tags/jni/"/>
    
      <category term="JNI&amp;amp;NDK" scheme="http://www.liuling123.com/categories/JNI-amp-NDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JNI崩溃问题定位]]></title>
    <link href="http://www.liuling123.com/2016/06/ndk-stack.html"/>
    <id>http://www.liuling123.com/2016/06/ndk-stack.html</id>
    <published>2016-06-20T13:37:00.000Z</published>
    <updated>2016-06-20T14:06:42.000Z</updated>
    <content type="html"><![CDATA[<p>一般native代码导致的崩溃问题，奔溃日志提示大概类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fatal signal 11 (SIGSEGV), code 1, fault addr 0x0 in tid 13261</span><br></pre></td></tr></table></figure>
<p>只有这样而没有详细的调用栈信息，这样我们开发者无法定位到JNI中到底哪一行导致程序崩掉的。根本无法定位问题所在，就更不用说解决问题了。</p>
<p>好在NDK给开发者们提供了ndk-stack工具（在NDK根目录下），我们可以通过ndk-stack工具来查看so库中崩溃的堆栈信息。</p>
<h4 id="NDK_u7F16_u8BD1_u65F6_u5DF2DEBUG_u6A21_u5F0F_u7F16_u8BD1"><a href="#NDK_u7F16_u8BD1_u65F6_u5DF2DEBUG_u6A21_u5F0F_u7F16_u8BD1" class="headerlink" title="NDK编译时已DEBUG模式编译"></a>NDK编译时已DEBUG模式编译</h4><p>如果是使用命令行编译，则使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ndk-build clean all NDK_DEBUG=1</span><br></pre></td></tr></table></figure>
<p>clean all 的意思是编译之前先清理全部上次编译生成的内容。NDK_DEBUG=1 意思是生成调试版本的文件。加了这个参数后 调试的时候能定位到源码行数。</p>
<a id="more"></a>
<p>如果是使用gradle，则写法如下（注意这里已经覆盖了gradle默认的NDK编译,详细请前往<a href="http://liuling123.com/2016/05/android-studio-gradle-ndk-config.html" target="_blank" rel="external">《Android Studio覆盖了gradle默认的NDK编译》</a>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task ndkBuild(type: Exec) &#123;&#10;    commandLine &#39;ndk-build&#39;, &#39;-C&#39;, file(&#39;src/main/jni&#39;).absolutePath, &#39;clean&#39;,&#39;all&#39;, &#39;NDK_DEBUG=1&#39;&#10;&#125;&#10;tasks.withType(JavaCompile) &#123;&#10;    compileTask -&#62; compileTask.dependsOn ndkBuild&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后记得在AndroidManifest.xml设置debuggable为true ，在Application节点中。</p>
<h4 id="ndk_u7F16_u8BD1so_u5E93_u5E76_u8FD0_u884C_u7A0B_u5E8F"><a href="#ndk_u7F16_u8BD1so_u5E93_u5E76_u8FD0_u884C_u7A0B_u5E8F" class="headerlink" title="ndk编译so库并运行程序"></a>ndk编译so库并运行程序</h4><p>前提是要搭建好NDK开发环境并在项目中集成NDK，不会的可以参考<a href="http://liuling123.com/2016/05/ubuntu-android-studio-ndk.html" target="_blank" rel="external">Ubuntu下NDK编译环境搭建及在Android Studio中集成NDK </a> 。</p>
<p>为了演示，我这里先模拟一个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC&#10;        (JNIEnv *env, jclass obj) &#123;&#10;    int * p = NULL;&#10;    *p = 1;    //&#36825;&#37324;&#20250;&#23548;&#33268;&#31243;&#24207;&#23849;&#28291;&#10;    return (jstring)(*env)-&#62; NewStringUTF(env, &#34;I am string from jni&#34;);&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4F7F_u7528ndk-stack_u5DE5_u5177_u5B9A_u4F4D_u5D29_u6E83_u4FE1_u606F"><a href="#u4F7F_u7528ndk-stack_u5DE5_u5177_u5B9A_u4F4D_u5D29_u6E83_u4FE1_u606F" class="headerlink" title="使用ndk-stack工具定位崩溃信息"></a>使用ndk-stack工具定位崩溃信息</h4><p>在命令行中执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat | &#20320;&#30340;NDK&#25152;&#22312;&#30340;&#36335;&#24452;/ndk-stack -sym &#20320;&#30340;&#39033;&#30446;&#25152;&#22312;&#30340;&#36335;&#24452;/app/src/main/obj/local/armeabi</span><br></pre></td></tr></table></figure>
<p>这里要确定，ndk编译后生成了”你的项目所在的路径/app/src/main/obj/local/armeabi”目录，也就是这个目录要存在。</p>
<p>执行完这个命令之后，终端会阻塞在那，一旦程序崩溃，就会在终端打印出崩溃信息栈。如图所示：<br><img src="http://7xnqm4.com1.z0.glb.clouddn.com/ndkstack.png" alt=""></p>
<p>从崩溃信息可以看出导致崩溃的代码是在com_liuling_ndkjnidemo_JniUtils.c中的13行。</p>
<p>打开com_liuling_ndkjnidemo_JniUtils.c文件查看代码，确实是在13行出的问题。<br><img src="http://7xnqm4.com1.z0.glb.clouddn.com/ndk-stack-jnicode.png" alt=""></p>
<p>能够定位崩溃所在的位置，就对于我们排查问题来说有很大的帮助，其实修复bug大部分时间都是在找哪里出的问题，能够快速找出哪里出的问题，问题也就很快修复了。</p>
<p>​​</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般native代码导致的崩溃问题，奔溃日志提示大概类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fatal signal 11 (SIGSEGV), code 1, fault addr 0x0 in tid 13261</span><br></pre></td></tr></table></figure>
<p>只有这样而没有详细的调用栈信息，这样我们开发者无法定位到JNI中到底哪一行导致程序崩掉的。根本无法定位问题所在，就更不用说解决问题了。</p>
<p>好在NDK给开发者们提供了ndk-stack工具（在NDK根目录下），我们可以通过ndk-stack工具来查看so库中崩溃的堆栈信息。</p>
<h4 id="NDK_u7F16_u8BD1_u65F6_u5DF2DEBUG_u6A21_u5F0F_u7F16_u8BD1"><a href="#NDK_u7F16_u8BD1_u65F6_u5DF2DEBUG_u6A21_u5F0F_u7F16_u8BD1" class="headerlink" title="NDK编译时已DEBUG模式编译"></a>NDK编译时已DEBUG模式编译</h4><p>如果是使用命令行编译，则使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ndk-build clean all NDK_DEBUG=1</span><br></pre></td></tr></table></figure>
<p>clean all 的意思是编译之前先清理全部上次编译生成的内容。NDK_DEBUG=1 意思是生成调试版本的文件。加了这个参数后 调试的时候能定位到源码行数。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="jni" scheme="http://www.liuling123.com/tags/jni/"/>
    
      <category term="JNI&amp;amp;NDK" scheme="http://www.liuling123.com/categories/JNI-amp-NDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初次尝试Kotlin]]></title>
    <link href="http://www.liuling123.com/2016/06/android_studio_kotlin.html"/>
    <id>http://www.liuling123.com/2016/06/android_studio_kotlin.html</id>
    <published>2016-06-13T14:27:00.000Z</published>
    <updated>2016-06-13T14:29:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E3AAndroid_Studio_u5B89_u88C5kotlin_u63D2_u4EF6"><a href="#u4E3AAndroid_Studio_u5B89_u88C5kotlin_u63D2_u4EF6" class="headerlink" title="为Android Studio安装kotlin插件"></a>为Android Studio安装kotlin插件</h2><p>在Android Studio中打开Settings-&gt;Plugins-&gt;Browse Repositories，输入kotlin搜索</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/plugin_kotlin.png" alt=""></p>
<a id="more"></a>
<h2 id="u521B_u5EFAAndroid_u9879_u76EE_u5E76_u914D_u7F6Ekotlin"><a href="#u521B_u5EFAAndroid_u9879_u76EE_u5E76_u914D_u7F6Ekotlin" class="headerlink" title="创建Android项目并配置kotlin"></a>创建Android项目并配置kotlin</h2><h3 id="u521B_u5EFAAndroid_u5DE5_u7A0B"><a href="#u521B_u5EFAAndroid_u5DE5_u7A0B" class="headerlink" title="创建Android工程"></a>创建Android工程</h3><p>在Android Studio新建一个Android 工程“KotlinDemo”，跟普通Android工程创建一样。</p>
<h3 id="u914D_u7F6E_u5DE5_u7A0B"><a href="#u914D_u7F6E_u5DE5_u7A0B" class="headerlink" title="配置工程"></a>配置工程</h3><p>在工程的build.gradle中添加kotlin版本以及依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;&#10;buildscript &#123;&#10;&#10;    ext.kotlin_version = &#39;1.0.2&#39; //kotlin&#29256;&#26412;&#10;&#10;    repositories &#123;&#10;        jcenter()&#10;    &#125;&#10;    dependencies &#123;&#10;        classpath &#39;com.android.tools.build:gradle:1.5.0&#39;&#10;        //kotlin&#20381;&#36182;&#10;        classpath &#34;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&#34;&#10;        classpath &#34;org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version&#34;&#10;&#10;        // NOTE: Do not place your application dependencies here; they belong&#10;        // in the individual module build.gradle files&#10;    &#125;&#10;&#125;&#10;&#10;allprojects &#123;&#10;    repositories &#123;&#10;        jcenter()&#10;    &#125;&#10;&#125;&#10;&#10;task clean(type: Delete) &#123;&#10;    delete rootProject.buildDir&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>kotlin_version为kotlin的版本，因为要保持一直，所以这里配置成一个全局变量，方便在其他地方使用。版本最好使用<a href="http://kotlinlang.org/docs/reference/using-gradle.html" target="_blank" rel="external">kotlin官方文档</a>中的最新版本。</p>
<p>然后在module中的build.gradle文件中使用kotlin插件以及kotlin依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;apply plugin: &#39;com.android.application&#39;&#10;apply plugin: &#39;kotlin-android&#39; //&#20351;&#29992;kotlin&#25554;&#20214;&#10;&#10;android &#123;&#10;    compileSdkVersion 22&#10;    buildToolsVersion &#34;22.0.1&#34;&#10;&#10;    defaultConfig &#123;&#10;        applicationId &#34;com.mymoney.kotlindemo&#34;&#10;        minSdkVersion 15&#10;        targetSdkVersion 22&#10;        versionCode 1&#10;        versionName &#34;1.0&#34;&#10;    &#125;&#10;    buildTypes &#123;&#10;        release &#123;&#10;            minifyEnabled false&#10;            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;&#10;dependencies &#123;&#10;    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])&#10;    testCompile &#39;junit:junit:4.12&#39;&#10;    compile &#39;com.android.support:appcompat-v7:22.2.1&#39;&#10;    compile &#39;com.android.support:design:22.2.1&#39;&#10;    compile &#34;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&#34; //&#28155;&#21152;kotlin&#20381;&#36182;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5C06Java_u4EE3_u7801_u8F6C_u6362_u6210Kotlin"><a href="#u5C06Java_u4EE3_u7801_u8F6C_u6362_u6210Kotlin" class="headerlink" title="将Java代码转换成Kotlin"></a>将Java代码转换成Kotlin</h3><p>新建Android工程中默认MainActivity.java代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;package com.mymoney.kotlindemo;&#10;&#10;import android.app.Activity;&#10;import android.os.Bundle;&#10;&#10;public class MainActivity extends Activity &#123;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) &#123;&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_main);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>打开该文件，使用快捷键Ctrl+Shift+Alt+K即可将该Java代码转换为Kotlin代码，也可以在Android Studio的菜单中使用Code-&gt;Convert Java File to Kotlin File进行转换。转换后的Kotlin代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;package com.mymoney.kotlindemo&#10;&#10;import android.app.Activity&#10;import android.os.Bundle&#10;&#10;class MainActivity : Activity() &#123;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) &#123;&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>完了之后点击Gradle的Sync按钮进行构建，就可以正常运行了。</p>
<p>​​</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E3AAndroid_Studio_u5B89_u88C5kotlin_u63D2_u4EF6"><a href="#u4E3AAndroid_Studio_u5B89_u88C5kotlin_u63D2_u4EF6" class="headerlink" title="为Android Studio安装kotlin插件"></a>为Android Studio安装kotlin插件</h2><p>在Android Studio中打开Settings-&gt;Plugins-&gt;Browse Repositories，输入kotlin搜索</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/plugin_kotlin.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.liuling123.com/tags/Kotlin/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="Kotlin" scheme="http://www.liuling123.com/categories/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[so库中JNI方法混淆]]></title>
    <link href="http://www.liuling123.com/2016/06/so_method_mix.html"/>
    <id>http://www.liuling123.com/2016/06/so_method_mix.html</id>
    <published>2016-06-02T14:51:00.000Z</published>
    <updated>2016-06-02T14:56:44.000Z</updated>
    <content type="html"><![CDATA[<p>​​默认情况下，使用JNI时与native对应的JNI函数名都是Java<em>包名(点替换为</em>)<em>类名</em>方法名，使用javah生成的头文件函数名就是这样的格式。这样的格式的so库被反汇编时很容易就找到对应的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC&#10;        (JNIEnv *env, jclass obj) &#123;&#10;    return (jstring)(*env)-&#62; NewStringUTF(env, &#34;I am string from jni&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上面是简单的一个JNI方法，我们将生成的so库使用IDA工具进行反汇编之后就能看到如下的内容：</p>
<p>在左边很容易就能找到Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC这个方法：</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/somix%2Fmethod.png" alt=""></p>
<p>双击该方法就能看到该方法反汇编之后的内容，这里返回的字符串”I am string from jni”就暴露出来了，如果是一些敏感信息比如一些key之类的东西，这样就存在着风险。</p>
<a id="more"></a>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/somix%2Fmethod_detail.png" alt=""></p>
<p>经上网搜索，发现有一种方法可以让JNI中的方法名不适用javah生成的风格，方法名随便取，并且可以将方法隐藏起来，反汇编之后找不到对应的方法，类似于Android中的混淆，加大了破解的难度。</p>
<p>这种方法的特点是：</p>
<ul>
<li>源码改动少，只需要添加JNI_Onload函数</li>
<li>无需加解密so，就可以实现混淆so中的JNI函数</li>
<li>后续可以添加so加解密，使破解难度更大 </li>
</ul>
<p>下面来看一个例子：</p>
<h4 id="Java_u5C42_u4EE3_u7801"><a href="#Java_u5C42_u4EE3_u7801" class="headerlink" title="Java层代码"></a>Java层代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;public class JniUtils &#123;&#10;    static &#123;&#10;        System.loadLibrary(&#34;NDKJNIDemo&#34;);//&#19982;build.gradle&#37324;&#38754;&#35774;&#32622;&#30340;so&#21517;&#23383;&#65292;&#24517;&#39035;&#19968;&#33268;&#10;    &#125;&#10;    public static native String getStringFromC();&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JNI_u5C42_u4EE3_u7801"><a href="#JNI_u5C42_u4EE3_u7801" class="headerlink" title="JNI层代码"></a>JNI层代码</h4><p>第一步：我们要写一个JNI_Onload，来自定义JNI函数的函数名，要加入头文件#include <assert.h></assert.h></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;#include &#60;assert.h&#62;&#10;#include &#34;com_liuling_ndkjnidemo_JniUtils.h&#34;&#10;&#10;#define JNIREG_CLASS &#34;com/liuling/ndkjnidemo/JniUtils&#34;//&#25351;&#23450;&#35201;&#27880;&#20876;&#30340;&#31867;&#10;&#10;/**&#10;* Table of methods associated with a single class.&#10;*/&#10;//&#32465;&#23450;&#65292;&#27880;&#24847;&#65292;V,Z&#31614;&#21517;&#30340;&#36820;&#22238;&#20540;&#19981;&#33021;&#26377;&#20998;&#21495;&#8220;;&#8221;&#10;//&#36825;&#37324;&#23601;&#26159;&#25226;JAVA&#23618;&#30340;getStringFromC()&#20989;&#25968;&#32465;&#23450;&#21040;Native&#23618;&#30340;getStringc()&#20989;&#25968;&#65292;&#23601;&#26080;&#38656;&#20351;&#29992;&#21407;&#29983;&#30340;Java_com_xx_xx_classname_methodname&#36825;&#31181;&#24694;&#24515;&#30340;&#20989;&#25968;&#21629;&#21517;&#26041;&#24335;&#20102;&#10;static JNINativeMethod gMethods[] = &#123;&#10;        &#123; &#34;getStringFromC&#34;, &#34;()Ljava/lang/String;&#34;, (void*)getStringc&#125;,&#10;&#10;&#125;;&#10;&#10;&#10;/*&#10;* Register several native methods for one class.&#10;*/&#10;&#10;static int registerNativeMethods(JNIEnv* env, const char* className,&#10;                                 JNINativeMethod* gMethods, int numMethods)&#10;&#123;&#10;    jclass clazz;&#10;    clazz = (*env)-&#62;FindClass(env, className);&#10;    if (clazz == NULL) &#123;&#10;        return JNI_FALSE;&#10;    &#125;&#10;    if ((*env)-&#62;RegisterNatives(env, clazz, gMethods, numMethods) &#60; 0) &#123;&#10;        return JNI_FALSE;&#10;    &#125;&#10;&#10;    return JNI_TRUE;&#10;&#125;&#10;&#10;&#10;/*&#10;* Register native methods for all classes we know about.&#10;*/&#10;&#10;static int registerNatives(JNIEnv* env)&#10;&#123;&#10;    if (!registerNativeMethods(env, JNIREG_CLASS, gMethods,&#10;                               sizeof(gMethods) / sizeof(gMethods[0])))&#10;        return JNI_FALSE;&#10;&#10;    return JNI_TRUE;&#10;&#125;&#10;&#10;&#10;/*&#10;* Set some test stuff up.&#10;*&#10;* Returns the JNI version on success, -1 on failure.&#10;*/&#10;&#10;jint JNI_OnLoad(JavaVM* vm, void* reserved)&#10;&#123;&#10;    JNIEnv* env = NULL;&#10;    jint result = -1;&#10;&#10;    if ((*vm)-&#62;GetEnv(vm, (void**) &#38;env, JNI_VERSION_1_4) != JNI_OK) &#123;&#10;        return -1;&#10;    &#125;&#10;    assert(env != NULL);&#10;&#10;    if (!registerNatives(env)) &#123;//&#27880;&#20876;&#10;        return -1;&#10;    &#125;&#10;&#10;/* success -- return valid version number */&#10;&#10;    result = JNI_VERSION_1_4;&#10;&#10;    return result;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：Java层函数所对应的函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;__attribute__((section (&#34;.mytext&#34;))) JNICALL jstring getStringc(JNIEnv *env, jclass obj) &#123;&#10;    return (jstring)(*env)-&#62; NewStringUTF(env, &#34;I am string from jni22222&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键是，在函数前加上<strong>attribute</strong>((section (“.mytext”)))，这样的话，编译的时候就会把这个函数编译到自定义的名叫”.mytext“的section里面去了。</p>
<p>最后一步：隐藏符号表，在Android.mk文件里面添加一句LOCAL_CFLAGS := -fvisibility=hidden</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;LOCAL_PATH := $(call my-dir)&#10;&#10;local_c_includes := \&#10;   $(NDK_PROJECT_PATH) \&#10;&#10;include $(CLEAR_VARS)&#10;&#10;LOCAL_CFLAGS := -fvisibility=hidden    #&#38544;&#34255;&#31526;&#21495;&#34920;&#10;&#10;LOCAL_MODULE    := NDKJNIDemo&#10;&#10;LOCAL_SRC_FILES := com_liuling_ndkjnidemo_JniUtils.c&#10;P&#10;include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>这样就OK了，程序跑起来的效果和之前没有任何区别。</p>
<p>下面我们用IDA来看一下混淆后的效果：</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/somix%2Fmethod_progard.png" alt=""></p>
<p>在IDA里面看不到getStringc()函数，其次getStringc()函数的符号表是没有的，这个函数放在.mytext里面，而且整个逻辑是完全混淆的，数据和代码混在一起了（其实是IDA以为是ARM指令），这样就加大了so库破解的难度。</p>
<p>上面混淆方案的实现原理其实很简单，当在系统中调用System.loadLibrary函数时，该函数会找到对应的so库，然后首先试图找到”JNI_OnLoad”函数，如果该函数存在，则调用它。</p>
<p>JNI_OnLoad可以和JNIEnv的registerNatives函数结合起来，实现动态的函数替换。如果在so库中没有找到”JNI_OnLoad”函数，则会在调用的时候解析javah风格的函数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>​​默认情况下，使用JNI时与native对应的JNI函数名都是Java<em>包名(点替换为</em>)<em>类名</em>方法名，使用javah生成的头文件函数名就是这样的格式。这样的格式的so库被反汇编时很容易就找到对应的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC&#10;        (JNIEnv *env, jclass obj) &#123;&#10;    return (jstring)(*env)-&#62; NewStringUTF(env, &#34;I am string from jni&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>上面是简单的一个JNI方法，我们将生成的so库使用IDA工具进行反汇编之后就能看到如下的内容：</p>
<p>在左边很容易就能找到Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC这个方法：</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/somix%2Fmethod.png" alt=""></p>
<p>双击该方法就能看到该方法反汇编之后的内容，这里返回的字符串”I am string from jni”就暴露出来了，如果是一些敏感信息比如一些key之类的东西，这样就存在着风险。</p>]]>
    
    </summary>
    
      <category term="NDK" scheme="http://www.liuling123.com/tags/NDK/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="jni" scheme="http://www.liuling123.com/tags/jni/"/>
    
      <category term="JNI&amp;amp;NDK" scheme="http://www.liuling123.com/categories/JNI-amp-NDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下NDK编译环境搭建及在Android Studio中集成NDK]]></title>
    <link href="http://www.liuling123.com/2016/05/ubuntu-android-studio-ndk.html"/>
    <id>http://www.liuling123.com/2016/05/ubuntu-android-studio-ndk.html</id>
    <published>2016-05-31T13:24:00.000Z</published>
    <updated>2016-05-31T14:27:45.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Ubuntu_u4E0BNDK_u73AF_u5883_u7684_u642D_u5EFA"><a href="#Ubuntu_u4E0BNDK_u73AF_u5883_u7684_u642D_u5EFA" class="headerlink" title="Ubuntu下NDK环境的搭建"></a>Ubuntu下NDK环境的搭建</h1><h2 id="NDK_u4E0B_u8F7D"><a href="#NDK_u4E0B_u8F7D" class="headerlink" title="NDK下载"></a>NDK下载</h2><p>首先需要下载NDK编译工具，目前官方最新的NDK版本是r11c，为了保证稳定性，我下的是r11b。</p>
<p>能翻墙的可以从谷歌官网下载，地址为：<a href="https://developer.android.com/ndk/downloads/index.html" target="_blank" rel="external">https://developer.android.com/ndk/downloads/index.html</a></p>
<p>不能翻墙的也可以从下面网站下载，该网站提供了Android开发各种工具的下载：<a href="http://www.androiddevtools.cn/index.html" target="_blank" rel="external">http://www.androiddevtools.cn/index.html</a></p>
<a id="more"></a>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fanddevtools_ndk_download.png" alt=""></p>
<h2 id="u914D_u7F6E_u73AF_u5883_u53D8_u91CF"><a href="#u914D_u7F6E_u73AF_u5883_u53D8_u91CF" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>将下载下来的文件进行解压，我这里解压到~/android/android-ndk-r11b。</p>
<p>然后在~/.profile文件中加入如下内容，将NDK目录加入到PATH中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set ndk environment&#10;export NDK_HOME=~/android/android-ndk-r11b&#10;export PATH=$PATH:$NDK_HOME</span><br></pre></td></tr></table></figure>
<p>最后执行“source ~/.profile”使之生效。</p>
<p>配置好环境变量之后，需要验证一下是否搭建成功，在命令行下输入ndk-build，有如下提示则表示搭建成功了。</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fndk-build-setup-ok.png" alt=""></p>
<h1 id="u5728Android_Studio_u4E2D_u96C6_u6210NDK"><a href="#u5728Android_Studio_u4E2D_u96C6_u6210NDK" class="headerlink" title="在Android Studio中集成NDK"></a>在Android Studio中集成NDK</h1><h2 id="u521B_u5EFAAndroid_u9879_u76EE"><a href="#u521B_u5EFAAndroid_u9879_u76EE" class="headerlink" title="创建Android项目"></a>创建Android项目</h2><p>在Android Studio中创建一个Android工程，我这里创建一个名为NDKJNIDemo的工程。</p>
<h2 id="u914D_u7F6Endk-dir"><a href="#u914D_u7F6Endk-dir" class="headerlink" title="配置ndk.dir"></a>配置ndk.dir</h2><p>在项目中的local.properties文件中添加如下代码来指定ndk的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;ndk.dir=~/android/android-ndk-r11b</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6Egradle_u7684ndk_u6A21_u5757"><a href="#u914D_u7F6Egradle_u7684ndk_u6A21_u5757" class="headerlink" title="配置gradle的ndk模块"></a>配置gradle的ndk模块</h2><p>在module的build.gradle文件的android.defaultConfig添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;ndk &#123;&#10;    moduleName &#34;NDKJNIDemo&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里配置的moduleName就是编译生成so库的名字，比如这里生成的so库名字为“libNDKJNIDemo.so”。</p>
<p>ndk还可以配置更多选项，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ndk &#123; &#10;    moduleName &#34;NDKJNIDemo&#34;&#10;    cFlags &#34;-DANDROID_NDK -D_DEBUG DNULL=0&#34;    // Define some macros&#10;    ldLibs &#34;EGL&#34;, &#34;GLESv3&#34;, &#34;dl&#34;, &#34;log&#34;        // Link with these libraries!&#10;    stl &#34;stlport_shared&#34;                       // Use shared stlport library&#10;    abiFilters &#34;armeabi&#34;, &#34;armeabi-v7a&#34;, &#34;x86&#34; // Set the platform&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6E_u7F16_u8BD1_u5E73_u53F0_uFF08_u53EF_u9009_uFF09"><a href="#u914D_u7F6E_u7F16_u8BD1_u5E73_u53F0_uFF08_u53EF_u9009_uFF09" class="headerlink" title="配置编译平台（可选）"></a>配置编译平台（可选）</h2><p>Android Studio默认会编译所有平台下的so库。</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fas-so-output.png" alt=""></p>
<p>如果你只想编译指定平台的so库，可以加入如下配置，在module的build.gradle文件的android中加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ndk &#123;&#10;      moduleName &#34;NDKJNIDemo&#34;&#10;      abiFilters &#34;armeabi&#34;, &#34;armeabi-v7a&#34;, &#34;x86&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fas-so-output-option.png" alt=""></p>
<h2 id="u521B_u5EFA_u5305_u542Bnative_u65B9_u6CD5_u7684_u7C7B"><a href="#u521B_u5EFA_u5305_u542Bnative_u65B9_u6CD5_u7684_u7C7B" class="headerlink" title="创建包含native方法的类"></a>创建包含native方法的类</h2><p>我这里创建了一个JniUtils类，并且创建了一个名为getStringFromC()的nativie方法，该方法作用就是简单的从JNI层返回一个字符串给Java层，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.liuling.ndkjnidemo;&#10;/**&#10; * Created by liuling on 16-5-16.&#10; */&#10;public class JniUtils &#123;&#10;    static &#123;&#10;        System.loadLibrary(&#34;NDKJNIDemo&#34;);//&#19982;build.gradle&#37324;&#38754;&#35774;&#32622;&#30340;so&#21517;&#23383;&#65292;&#24517;&#39035;&#19968;&#33268;&#10;    &#125;&#10;    public static native String getStringFromC();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这里得注意loadLibrary加载的so库的名字必须和上面第3步配置的moduleName保持一直，否则会报找不到库文件的异常。</p>
<h2 id="u521B_u5EFAC/C++_u6E90_u4EE3_u7801"><a href="#u521B_u5EFAC/C++_u6E90_u4EE3_u7801" class="headerlink" title="创建C/C++源代码"></a>创建C/C++源代码</h2><h3 id="u751F_u6210_u5934_u6587_u4EF6"><a href="#u751F_u6210_u5934_u6587_u4EF6" class="headerlink" title="生成头文件"></a>生成头文件</h3><p>进入module/build/intermediates/classes/debug目录下，在命令行下使用javah生成头文件，我这里是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd app/build/intermediates/classes/debug&#10;javah -jni com.liuling.ndkjnidemo.JniUtils</span><br></pre></td></tr></table></figure>
<p>完了之后会在module/build/intermediates/classes/debug目录下生成相应的头文件，我这里生成的是com_liuling_ndkjnidemo_JniUtils.h，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* DO NOT EDIT THIS FILE - it is machine generated */&#10;#include &#60;jni.h&#62;&#10;#include &#60;string.h&#62;&#10;/* Header for class com_liuling_ndkjnidemo_JniUtils */&#10;#ifndef _Included_com_liuling_ndkjnidemo_JniUtils&#10;#define _Included_com_liuling_ndkjnidemo_JniUtils&#10;#ifdef __cplusplus&#10;extern &#34;C&#34; &#123;&#10;#endif&#10;/*&#10; * Class:     com_liuling_ndkjnidemo_JniUtils&#10; * Method:    getStringFormC&#10; * Signature: ()Ljava/lang/String;&#10; */&#10;JNIEXPORT jstring JNICALL Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC&#10;  (JNIEnv *, jclass);&#10;#ifdef __cplusplus&#10;&#125;&#10;#endif&#10;#endif</span><br></pre></td></tr></table></figure>
<h3 id="u521B_u5EFAjni_u76EE_u5F55"><a href="#u521B_u5EFAjni_u76EE_u5F55" class="headerlink" title="创建jni目录"></a>创建jni目录</h3><p>在module/src/main/下面新建jni目录，ndk会默认编译该目录下的源文件。目录结构如下图：</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fjni-struts.png" alt=""></p>
<p>当然，你也可以自定义C/C++源代码目录，在module的build.gradle文件的android中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;&#10;    main &#123;&#10;        jni.srcDirs &#39;src/main/jnisrc&#39;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u62F7_u8D1D_u5934_u6587_u4EF6_u5230C/C++_u6E90_u4EE3_u7801_u76EE_u5F55_u5E76_u521B_u5EFAC_u6E90_u6587_u4EF6"><a href="#u62F7_u8D1D_u5934_u6587_u4EF6_u5230C/C++_u6E90_u4EE3_u7801_u76EE_u5F55_u5E76_u521B_u5EFAC_u6E90_u6587_u4EF6" class="headerlink" title="拷贝头文件到C/C++源代码目录并创建C源文件"></a>拷贝头文件到C/C++源代码目录并创建C源文件</h3><p>将前面生成的头文件拷贝到C/C++源代码目录，并创建相应的C代码文件，我这里创建了com_liuling_ndkjnidemo_JniUtils.c，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &#34;com_liuling_ndkjnidemo_JniUtils.h&#34;&#10;/*&#10; * Class:     com_liuling_ndkjnidemo_JniUtils&#10; * Method:    getStringFormC&#10; * Signature: ()Ljava/lang/String;&#10; */&#10;JNIEXPORT jstring JNICALL Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC&#10;        (JNIEnv *env, jclass obj) &#123;&#10;    return (jstring)(*env)-&#62; NewStringUTF(env, &#34;I am string from jni-jnisrc&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Java_com_liuling_ndkjnidemo_JniUtils_getStringFromC方法就是对应JniUtils里的native方法getStringFromC()。</p>
<h2 id="u8FD0_u884C_u6548_u679C"><a href="#u8FD0_u884C_u6548_u679C" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fjni-sample.png" alt=""></p>
<h1 id="Gradle_u914D_u7F6E_u8986_u76D6_u9ED8_u8BA4NDK_u7F16_u8BD1"><a href="#Gradle_u914D_u7F6E_u8986_u76D6_u9ED8_u8BA4NDK_u7F16_u8BD1" class="headerlink" title="Gradle配置覆盖默认NDK编译"></a>Gradle配置覆盖默认NDK编译</h1><p>大家会发现几个问题：</p>
<ul>
<li><p>为什么运行程序之后在main下面没找到so库呢？</p>
</li>
<li><p>为什么编译时不需要Android.mk文件呢？</p>
</li>
</ul>
<p>默认情况下ndk将生成的so库放到了build下面去了，同时也会使用一个默认的Android.mk文件进行编译，如下图：</p>
<p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/asndk%2Fdefault-mk.png" alt=""></p>
<p>那我们能否覆盖默认的设置呢？答案时肯定的！</p>
<p>首先在项目gradle文件的android{}中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;&#10;    main &#123;&#10;        jni.srcDirs = []   //&#23631;&#34109;gradle&#30340;jni&#29983;&#25104;&#36807;&#31243;&#10;        jniLibs.srcDir &#39;src/main/libs&#39;  //&#25351;&#23450;&#24341;&#29992;so&#24211;&#30340;&#30446;&#24405;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后在gradle文件最底部添加一个ndk编译task：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task ndkBuild(type: Exec) &#123;&#10;    commandLine &#39;ndk-build&#39;, &#39;-C&#39;, file(&#39;src/main/jni&#39;).absolutePath&#10;&#125;&#10;tasks.withType(JavaCompile) &#123;&#10;    compileTask -&#62; compileTask.dependsOn ndkBuild&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：使用上述命令必须确定ndk的环境变量配置好了，也就是确定ndk的目录加到PATH中去了，否则该任务会执行失败。</p>
<p>最后自己在jni目录下面建立Android.mk和Application.mk文件，直接点击AS上的运行就会先执行NDK编译的过程。</p>
<p>Android.mk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)&#10;local_c_includes := \&#10;&#9;$(NDK_PROJECT_PATH) \&#10;&#9;&#10;include $(CLEAR_VARS)&#10;# so&#24211;&#21517;&#23383;&#10;LOCAL_MODULE    := NDKJNIDemo &#10;LOCAL_SRC_FILES := com_liuling_ndkjnidemo_JniUtils.c&#10;# &#28155;&#21152;log&#27169;&#22359;&#10;LOCAL_LDLIBS    := -lm -llog&#10;include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>Application.mk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP_ABI := armeabi x86&#10;#&#20351;NDK&#25903;&#25345;string&#10;APP_STL := stlport_shared&#10;APP_STL := stlport_static</span><br></pre></td></tr></table></figure>
<p>可以看到，默认情况下可以在gradle中的ndk中配置以上这些信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ndk &#123;&#10;    moduleName &#34;NDKJNIDemo&#34;&#10;    ldLibs &#34;log&#34;&#10;    stl &#34;stlport_shared&#34;&#10;    abiFilters &#34;armeabi&#34;, &#34;x86&#34; &#10;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Ubuntu_u4E0BNDK_u73AF_u5883_u7684_u642D_u5EFA"><a href="#Ubuntu_u4E0BNDK_u73AF_u5883_u7684_u642D_u5EFA" class="headerlink" title="Ubuntu下NDK环境的搭建"></a>Ubuntu下NDK环境的搭建</h1><h2 id="NDK_u4E0B_u8F7D"><a href="#NDK_u4E0B_u8F7D" class="headerlink" title="NDK下载"></a>NDK下载</h2><p>首先需要下载NDK编译工具，目前官方最新的NDK版本是r11c，为了保证稳定性，我下的是r11b。</p>
<p>能翻墙的可以从谷歌官网下载，地址为：<a href="https://developer.android.com/ndk/downloads/index.html">https://developer.android.com/ndk/downloads/index.html</a></p>
<p>不能翻墙的也可以从下面网站下载，该网站提供了Android开发各种工具的下载：<a href="http://www.androiddevtools.cn/index.html">http://www.androiddevtools.cn/index.html</a></p>]]>
    
    </summary>
    
      <category term="NDK" scheme="http://www.liuling123.com/tags/NDK/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="jni" scheme="http://www.liuling123.com/tags/jni/"/>
    
      <category term="JNI&amp;amp;NDK" scheme="http://www.liuling123.com/categories/JNI-amp-NDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio在Gradle中配置NDK编译，覆盖默认NDK编译]]></title>
    <link href="http://www.liuling123.com/2016/05/android-studio-gradle-ndk-config.html"/>
    <id>http://www.liuling123.com/2016/05/android-studio-gradle-ndk-config.html</id>
    <published>2016-05-18T13:07:00.000Z</published>
    <updated>2016-05-18T13:19:33.000Z</updated>
    <content type="html"><![CDATA[<p>默认情况下，存在src/main/jni文件夹时，gradle生成脚本会执行ndk编译生成操作，但是，编译生成方式并不是像以前那样用ndk-build去处理Android.mk Application.mk等进行c/c++代码的编译链接，而是在临时文件路径中重新生成了一份新的mk文件，并以此作为ndk编译项目。</p>
<p>如果我们想自己在jni目录下面建立Android.mk和Application.mk来进行编译，比如在so库中加入log打印功能，则需要在Android.mk中将log库编译到so文件，此时要怎么做呢？</p>
<p>首先在项目gradle文件的android{}中添加如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;&#10;    main &#123;&#10;        jni.srcDirs = []   //&#23631;&#34109;gradle&#30340;jni&#29983;&#25104;&#36807;&#31243;&#10;        jniLibs.srcDir &#39;src/main/libs&#39;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后在gradle文件最底部添加一个ndk编译任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task ndkBuild(type: Exec) &#123;&#10;    commandLine &#39;ndk-build&#39;, &#39;-C&#39;, file(&#39;src/main/jni&#39;).absolutePath&#10;&#125;&#10;tasks.withType(JavaCompile) &#123;&#10;    compileTask -&#62; compileTask.dependsOn ndkBuild&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：使用上述命令必须确定ndk的环境变量配置好了，也就是确定ndk的目录加到PATH中去了，否则该任务会执行失败。</p>
<p>在MAC中不能直接使用ndk-build，会找不到命令，即使已经在～/.bash_profile中将ndk目录加入到PATH中了也一样。需要使用绝对路径，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commandLine &#39;/User/xxx/xxx/ndk-build&#39;, &#39;-C&#39;, file(&#39;src/main/jni&#39;).absolutePath</span><br></pre></td></tr></table></figure></p>
<p>最后自己在jni目录下面建立Android.mk和Application.mk文件，直接点击AS上的运行就会先执行NDK编译的过程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>默认情况下，存在src/main/jni文件夹时，gradle生成脚本会执行ndk编译生成操作，但是，编译生成方式并不是像以前那样用ndk-build去处理Android.mk Application.mk等进行c/c++代码的编译链接，而是在临时文件路径中重新生成了一份新的mk文件，并以此作为ndk编译项目。</p>
<p>如果我们想自己在jni目录下面建立Android.mk和Application.mk来进行编译，比如在so库中加入log打印功能，则需要在Android.mk中将log库编译到so文件，此时要怎么做呢？</p>
<p>首先在项目gradle文件的android{}中添加如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;&#10;    main &#123;&#10;        jni.srcDirs = []   //&#23631;&#34109;gradle&#30340;jni&#29983;&#25104;&#36807;&#31243;&#10;        jniLibs.srcDir &#39;src/main/libs&#39;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="NDK" scheme="http://www.liuling123.com/tags/NDK/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="jni" scheme="http://www.liuling123.com/tags/jni/"/>
    
      <category term="JNI&amp;amp;NDK" scheme="http://www.liuling123.com/categories/JNI-amp-NDK/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android自动化反编译脚本]]></title>
    <link href="http://www.liuling123.com/2016/05/auto-decompiler.html"/>
    <id>http://www.liuling123.com/2016/05/auto-decompiler.html</id>
    <published>2016-05-15T05:22:00.000Z</published>
    <updated>2016-05-15T05:23:09.000Z</updated>
    <content type="html"><![CDATA[<p>作为Android开发人员，在开发过程中经常会因为某个原因去反编译某个app。为了方便，这里特意整理了一个反编译的自动化脚本，只需一个命令就可以获取apk文件里面的资源文件，并使用jd－gui工具打开生成的jar文件。省去每次都要手动敲每个工具的命令，有时候忘记了某个命令还得上网搜索，很麻烦。</p>
<p>这里只整理了Linux和Mac两个平台的自动化脚本，Win下的百度能搜索的到。</p>
<h3 id="u6240_u9700_u8981_u7684_u5DE5_u5177"><a href="#u6240_u9700_u8981_u7684_u5DE5_u5177" class="headerlink" title="所需要的工具"></a>所需要的工具</h3><p>1）apktool，功能：反编译出apk所需要的资源文件和布局设置文件等，<br>下载地址：<a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="external">http://ibotpeaches.github.io/Apktool/install/</a></p>
<p>2）dex2jar，功能：反编译出jar文件，即apk的源程序文件的字节码，<br>下载地址：<a href="http://code.google.com/p/dex2jar/downloads/list" target="_blank" rel="external">http://code.google.com/p/dex2jar/downloads/list</a></p>
<p>3）jd-gui 功能：查看反编译出来的jar文件<br>下载地址：<a href="http://jd.benow.ca/" target="_blank" rel="external">http://jd.benow.ca/</a></p>
<p>这些工具我都整理好了，下面附了Linux和Mac平台的工具下载链接，并且包含了自动化脚本工具，可以直接下载使用。</p>
<a id="more"></a>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>自动化脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh  &#10;&#10;# will be decompiled file&#10;file_name=$1&#10;export NAME=$&#123;file_name%.apk&#125;&#10;export APK_TOOLS=$PWD/tools/apktool-2.1.1&#10;export DEX_JAR=$PWD/tools/dex2jar-0.0.9.15&#10;export JD_GUI=$PWD/tools/jd-gui-0.3.5.linux.i686&#10;&#10;#init  &#10;rm -rf tmp&#10;&#10;#apply apktool  &#10;cd $APK_TOOLS&#10;rm -rf ../../$NAME&#10;./apktool d -f ../../$&#123;file_name&#125;&#10;mv $NAME ../../&#10;&#10;#unzip  &#10;cd $APK_TOOLS/../..&#10;mkdir -p tmp&#10;cp $&#123;file_name&#125; tmp/$NANME.zip&#10;cd tmp&#10;unzip $NANME.zip&#10;cd ..&#10;cp ./tmp/$NANME/classes.dex $NAME&#10;&#10;#use dex2jar to get classes_dex2jar.jar  &#10;$DEX_JAR/dex2jar.sh $NAME/classes.dex&#10;rm -rf tmp&#10;&#10;#prepre open classes_dex2jar.jar&#10;$JD_GUI/jd-gui $NAME/classes_dex2jar.jar</span><br></pre></td></tr></table></figure></p>
<p>Linux下反编译工具下载链接：<a href="http://download.csdn.net/detail/a476777389/9520707" target="_blank" rel="external">http://download.csdn.net/detail/a476777389/9520707</a></p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>自动化脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh  &#10;&#10;# will be decompiled file&#10;file_name=$1&#10;export NAME=$&#123;file_name%.apk&#125;&#10;export APK_TOOLS=$PWD/tools/apktool-2.1.1&#10;export DEX_JAR=$PWD/tools/dex2jar-0.0.9.15&#10;export JD_GUI=$PWD/tools/jd-gui-osx-1.4.0&#10;&#10;#init  &#10;rm -rf tmp&#10;#apply apktool  &#10;cd $APK_TOOLS&#10;rm -rf ../../$NAME&#10;./apktool d -f ../../$&#123;file_name&#125;&#10;mv $NAME ../../&#10;&#10;#unzip  &#10;cd $APK_TOOLS/../..&#10;mkdir -p tmp&#10;cp $&#123;file_name&#125; tmp/$NANME.zip&#10;cd tmp&#10;unzip $NANME.zip&#10;cd ..&#10;cp ./tmp/$NANME/classes.dex $NAME&#10;&#10;#use dex2jar to get classes_dex2jar.jar  &#10;$DEX_JAR/d2j-dex2jar.sh $NAME/classes.dex&#10;rm -rf tmp &#10;mv classes-dex2jar.jar $NAME&#10;&#10;#prepre open classes_dex2jar.jar&#10;open -a $JD_GUI/JD-GUI.app $NAME/classes-dex2jar.jar</span><br></pre></td></tr></table></figure></p>
<p>Mac下反编译工具下载链接：<a href="http://download.csdn.net/detail/a476777389/9520676" target="_blank" rel="external">http://download.csdn.net/detail/a476777389/9520676</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为Android开发人员，在开发过程中经常会因为某个原因去反编译某个app。为了方便，这里特意整理了一个反编译的自动化脚本，只需一个命令就可以获取apk文件里面的资源文件，并使用jd－gui工具打开生成的jar文件。省去每次都要手动敲每个工具的命令，有时候忘记了某个命令还得上网搜索，很麻烦。</p>
<p>这里只整理了Linux和Mac两个平台的自动化脚本，Win下的百度能搜索的到。</p>
<h3 id="u6240_u9700_u8981_u7684_u5DE5_u5177"><a href="#u6240_u9700_u8981_u7684_u5DE5_u5177" class="headerlink" title="所需要的工具"></a>所需要的工具</h3><p>1）apktool，功能：反编译出apk所需要的资源文件和布局设置文件等，<br>下载地址：<a href="http://ibotpeaches.github.io/Apktool/install/">http://ibotpeaches.github.io/Apktool/install/</a></p>
<p>2）dex2jar，功能：反编译出jar文件，即apk的源程序文件的字节码，<br>下载地址：<a href="http://code.google.com/p/dex2jar/downloads/list">http://code.google.com/p/dex2jar/downloads/list</a></p>
<p>3）jd-gui 功能：查看反编译出来的jar文件<br>下载地址：<a href="http://jd.benow.ca/">http://jd.benow.ca/</a></p>
<p>这些工具我都整理好了，下面附了Linux和Mac平台的工具下载链接，并且包含了自动化脚本工具，可以直接下载使用。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="反编译" scheme="http://www.liuling123.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus源码解析]]></title>
    <link href="http://www.liuling123.com/2016/01/EventBus-source.html"/>
    <id>http://www.liuling123.com/2016/01/EventBus-source.html</id>
    <published>2016-01-12T13:29:00.000Z</published>
    <updated>2016-01-12T13:38:36.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>前面一篇文章讲解了EventBus的使用，但是作为开发人员，不能只停留在仅仅会用的层面上，我们还需要弄清楚它的内部实现原理。所以本篇博文将分析EventBus的源码，看看究竟它是如何实现“发布/订阅”功能的。</p>
<p>相关文章<br><a href="http://liuling123.com/2016/01/EventBus-explain.html" target="_blank" rel="external">EventBus使用详解</a><br><a href="http://liuling123.com/2016/01/EventBus-source.html" target="_blank" rel="external">EventBus源码解析</a></p>
</blockquote>
<h3 id="u4E8B_u4EF6_u6CE8_u518C"><a href="#u4E8B_u4EF6_u6CE8_u518C" class="headerlink" title="事件注册"></a>事件注册</h3><p>根据前一讲<a href="http://liuling123.com/2016/01/EventBus-explain.html" target="_blank" rel="external">EventBus使用详解</a>我们已经知道EventBus使用首先是需要注册的，注册事件的代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>EventBus对外提供了一个register方法来进行事件注册，该方法接收一个Object类型的参数，下面看下register方法的源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;&#10;    Class&#60;?&#62; subscriberClass = subscriber.getClass();&#10;    // &#21028;&#26029;&#35813;&#31867;&#26159;&#21542;&#26159;&#21311;&#21517;&#20869;&#37096;&#31867;&#10;    boolean forceReflection = subscriberClass.isAnonymousClass();&#10;    List&#60;SubscriberMethod&#62; subscriberMethods =&#10;            subscriberMethodFinder.findSubscriberMethods(subscriberClass, forceReflection);&#10;    for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;&#10;        subscribe(subscriber, subscriberMethod);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>该方法首先获取获取传进来参数的Class对象，然后判断该类是否是匿名内部类。然后根据这两个参数通过subscriberMethodFinder.findSubscriberMethods方法获取所有的事件处理方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&#60;SubscriberMethod&#62; findSubscriberMethods(Class&#60;?&#62; subscriberClass, boolean forceReflection) &#123;&#10;    String key = subscriberClass.getName();&#10;    List&#60;SubscriberMethod&#62; subscriberMethods;&#10;    synchronized (METHOD_CACHE) &#123;&#10;        subscriberMethods = METHOD_CACHE.get(key);&#10;    &#125;&#10;    if (subscriberMethods != null) &#123;&#10;        //&#32531;&#23384;&#21629;&#20013;&#65292;&#30452;&#25509;&#36820;&#22238;&#10;        return subscriberMethods;&#10;    &#125;&#10;    if (INDEX != null &#38;&#38; !forceReflection) &#123;&#10;        // &#22914;&#26524;INDEX&#19981;&#20026;&#31354;&#65292;&#24182;&#19988;subscriberClass&#20026;&#38750;&#21311;&#21517;&#20869;&#37096;&#31867;&#65292;&#10;        // &#21017;&#36890;&#36807;findSubscriberMethodsWithIndex&#26041;&#27861;&#26597;&#25214;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#10;        subscriberMethods = findSubscriberMethodsWithIndex(subscriberClass);&#10;        if (subscriberMethods.isEmpty()) &#123;&#10;            //&#22914;&#26524;&#32467;&#26524;&#20026;&#31354;&#65292;&#21017;&#20351;&#29992;findSubscriberMethodsWithReflection&#26041;&#27861;&#20877;&#26597;&#25214;&#19968;&#27425;&#10;            subscriberMethods = findSubscriberMethodsWithReflection(subscriberClass);&#10;        &#125;&#10;    &#125; else &#123;&#10;        //INDEX&#20026;&#31354;&#25110;&#32773;subscriberClass&#26410;&#21311;&#21517;&#20869;&#37096;&#31867;&#65292;&#20351;&#29992;findSubscriberMethodsWithReflection&#26041;&#27861;&#26597;&#25214;&#10;        subscriberMethods = findSubscriberMethodsWithReflection(subscriberClass);&#10;    &#125;&#10;    if (subscriberMethods.isEmpty()) &#123;&#10;        throw new EventBusException(&#34;Subscriber &#34; + subscriberClass&#10;                + &#34; and its super classes have no public methods with the @Subscribe annotation&#34;);&#10;    &#125; else &#123;&#10;        //&#23384;&#20837;&#32531;&#23384;&#24182;&#36820;&#22238;&#10;        synchronized (METHOD_CACHE) &#123;&#10;            METHOD_CACHE.put(key, subscriberMethods);&#10;        &#125;&#10;        return subscriberMethods;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>通过名字我们就知道这个方法是获取subscriberClass类中所有的事件处理方法（即使用了@Subscribe的方法）。该方法首先会从缓存METHOD_CACHE中去获取事件处理方法，如果缓存中不存在，则需要通过findSubscriberMethodsWithIndex或者findSubscriberMethodsWithReflection方法获取所有事件处理方法，获取到之后先存入缓存再返回。</p>
<p>这个方法里面有个INDEX对象，我们看看它是个什么鬼：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Optional generated index without entries from subscribers super classes */&#10;private static final SubscriberIndex INDEX;&#10;&#10;static &#123;&#10;    SubscriberIndex newIndex = null;&#10;    try &#123;&#10;        Class&#60;?&#62; clazz = Class.forName(&#34;de.greenrobot.event.GeneratedSubscriberIndex&#34;);&#10;        newIndex = (SubscriberIndex) clazz.newInstance();&#10;    &#125; catch (ClassNotFoundException e) &#123;&#10;        Log.d(EventBus.TAG, &#34;No subscriber index available, reverting to dynamic look-up&#34;);&#10;        // Fine&#10;    &#125; catch (Exception e) &#123;&#10;        Log.w(EventBus.TAG, &#34;Could not init subscriber index, reverting to dynamic look-up&#34;, e);&#10;    &#125;&#10;    INDEX = newIndex;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上面代码可以看出EventBus会试图加载一个de.greenrobot.event.GeneratedSubscriberIndex类并创建对象赋值给INDEX，但是EventBus3.0 beta并没有为我们提供该类（可能后续版本会提供）。所以INDEX为null。</p>
<p>我们再返回findSubscriberMethods方法，我们知道INDEX已经为null了，所以必然会调用findSubscriberMethodsWithReflection方法查找所有事件处理函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&#60;SubscriberMethod&#62; findSubscriberMethodsWithReflection(Class&#60;?&#62; subscriberClass) &#123;&#10;    List&#60;SubscriberMethod&#62; subscriberMethods = new ArrayList&#60;SubscriberMethod&#62;();&#10;    Class&#60;?&#62; clazz = subscriberClass;&#10;    HashSet&#60;String&#62; eventTypesFound = new HashSet&#60;String&#62;();&#10;    StringBuilder methodKeyBuilder = new StringBuilder();&#10;    while (clazz != null) &#123;&#10;        String name = clazz.getName();&#10;        // &#22914;&#26524;&#26597;&#25214;&#30340;&#31867;&#26159;java&#12289;javax&#25110;&#32773;android&#21253;&#19979;&#38754;&#30340;&#31867;&#65292;&#21017;&#36807;&#28388;&#25481;&#10;        if (name.startsWith(&#34;java.&#34;) || name.startsWith(&#34;javax.&#34;) || name.startsWith(&#34;android.&#34;)) &#123;&#10;            // Skip system classes, this just degrades performance&#10;            break;&#10;        &#125;&#10;&#10;        // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)&#10;        // &#36890;&#36807;&#21453;&#23556;&#26597;&#25214;&#25152;&#26377;&#35813;&#31867;&#20013;&#25152;&#26377;&#26041;&#27861;&#10;        Method[] methods = clazz.getDeclaredMethods();&#10;        for (Method method : methods) &#123;&#10;            int modifiers = method.getModifiers();&#10;            // &#20107;&#20214;&#22788;&#29702;&#26041;&#27861;&#24517;&#39035;&#20026;public&#65292;&#36825;&#37324;&#36807;&#28388;&#25481;&#25152;&#26377;&#38750;public&#26041;&#27861;&#10;            if ((modifiers &#38; Modifier.PUBLIC) != 0 &#38;&#38; (modifiers &#38; MODIFIERS_IGNORE) == 0) &#123;&#10;                Class&#60;?&#62;[] parameterTypes = method.getParameterTypes();&#10;                // &#20107;&#20214;&#22788;&#29702;&#26041;&#27861;&#24517;&#39035;&#21482;&#26377;&#19968;&#20010;&#21442;&#25968;&#10;                if (parameterTypes.length == 1) &#123;&#10;                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);&#10;                    if (subscribeAnnotation != null) &#123;&#10;                        String methodName = method.getName();&#10;                        Class&#60;?&#62; eventType = parameterTypes[0];&#10;                        methodKeyBuilder.setLength(0);&#10;                        methodKeyBuilder.append(methodName);&#10;                        methodKeyBuilder.append(&#39;&#62;&#39;).append(eventType.getName());&#10;&#10;                        String methodKey = methodKeyBuilder.toString();&#10;                        if (eventTypesFound.add(methodKey)) &#123;&#10;                            // Only add if not already found in a sub class&#10;                            // &#21482;&#26377;&#22312;&#23376;&#31867;&#20013;&#27809;&#26377;&#25214;&#21040;&#65292;&#25165;&#20250;&#28155;&#21152;&#21040;subscriberMethods&#10;                            ThreadMode threadMode = subscribeAnnotation.threadMode();&#10;                            subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,&#10;                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));&#10;                        &#125;&#10;                    &#125;&#10;                &#125; else if (strictMethodVerification) &#123;&#10;                    // &#22914;&#26524;&#26576;&#20010;&#26041;&#27861;&#21152;&#20102;@Subscribe&#27880;&#35299;&#65292;&#24182;&#19988;&#19981;&#26159;1&#20010;&#21442;&#25968;&#65292;&#21017;&#25243;&#20986;EventBusException&#24322;&#24120;&#10;                    if (method.isAnnotationPresent(Subscribe.class)) &#123;&#10;                        String methodName = name + &#34;.&#34; + method.getName();&#10;                        throw new EventBusException(&#34;@Subscribe method &#34; + methodName +&#10;                                &#34;must have exactly 1 parameter but has &#34; + parameterTypes.length);&#10;                    &#125;&#10;                &#125;&#10;            &#125; else if (strictMethodVerification) &#123;&#10;                // &#22914;&#26524;&#26576;&#20010;&#26041;&#27861;&#21152;&#20102;@Subscribe&#27880;&#35299;&#65292;&#24182;&#19988;&#19981;&#26159;public&#20462;&#39280;&#65292;&#21017;&#25243;&#20986;EventBusException&#24322;&#24120;&#10;                if (method.isAnnotationPresent(Subscribe.class)) &#123;&#10;                    String methodName = name + &#34;.&#34; + method.getName();&#10;                    throw new EventBusException(methodName +&#10;                            &#34; is a illegal @Subscribe method: must be public, non-static, and non-abstract&#34;);&#10;                &#125;&#10;&#10;            &#125;&#10;        &#125;&#10;        // &#20250;&#32487;&#32493;&#26597;&#25214;&#29238;&#31867;&#30340;&#26041;&#27861;&#10;        clazz = clazz.getSuperclass();&#10;    &#125;&#10;    return subscriberMethods;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要作用就是找出subscriberClass类以及subscriberClass的父类中所有的事件处理方法（添加了@Subscribe注解，访问修饰符为public并且只有一个参数）。值得注意的是：如果子类与父类中同时存在了相同事件处理函数，则父类中的不会被添加到subscriberMethods。</p>
<p>好了，查找事件处理函数的过程已经完了，我们继续回到register方法中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;&#10;    subscribe(subscriber, subscriberMethod);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>找到事件处理函数后，会遍历找到的所有事件处理函数并调用subscribe方法将所有事件处理函数注册到EventBus中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;&#10;    Class&#60;?&#62; eventType = subscriberMethod.eventType;&#10;    // &#33719;&#21462;&#35746;&#38405;&#20102;&#26576;&#31181;&#31867;&#22411;&#25968;&#25454;&#30340; Subscription &#12290; &#20351;&#29992;&#20102; CopyOnWriteArrayList &#65292;&#36825;&#20010;&#26159;&#32447;&#31243;&#23433;&#20840;&#30340;&#65292;&#10;    // CopyOnWriteArrayList &#20250;&#22312;&#26356;&#26032;&#30340;&#26102;&#20505;&#65292;&#37325;&#26032;&#29983;&#25104;&#19968;&#20221; copy&#65292;&#20854;&#20182;&#32447;&#31243;&#20351;&#29992;&#30340;&#26159; &#10;    // copy&#65292;&#19981;&#23384;&#22312;&#20160;&#20040;&#32447;&#31243;&#23433;&#20840;&#24615;&#30340;&#38382;&#39064;&#12290;&#10;    CopyOnWriteArrayList&#60;Subscription&#62; subscriptions = subscriptionsByEventType.get(eventType);&#10;    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);&#10;    if (subscriptions == null) &#123;&#10;        subscriptions = new CopyOnWriteArrayList&#60;Subscription&#62;();&#10;        subscriptionsByEventType.put(eventType, subscriptions);&#10;    &#125; else &#123;&#10;        //&#22914;&#26524;&#24050;&#32463;&#34987;&#27880;&#20876;&#36807;&#20102;&#65292;&#21017;&#25243;&#20986;EventBusException&#24322;&#24120;&#10;        if (subscriptions.contains(newSubscription)) &#123;&#10;            throw new EventBusException(&#34;Subscriber &#34; + subscriber.getClass() + &#34; already registered to event &#34;&#10;                    + eventType);&#10;        &#125;&#10;    &#125;&#10;&#10;    // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again)&#10;    // subscriberMethod.method.setAccessible(true);&#10;&#10;    // Got to synchronize to avoid shifted positions when adding/removing concurrently&#10;    // &#26681;&#25454;&#20248;&#20808;&#32423;&#23558;newSubscription&#26597;&#21040;&#21512;&#36866;&#20301;&#32622;&#10;    synchronized (subscriptions) &#123;&#10;        int size = subscriptions.size();&#10;        for (int i = 0; i &#60;= size; i++) &#123;&#10;            if (i == size || subscriberMethod.priority &#62; subscriptions.get(i).subscriberMethod.priority) &#123;&#10;                subscriptions.add(i, newSubscription);&#10;                break;&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#10;    //&#23558;&#22788;&#29702;&#20107;&#20214;&#31867;&#22411;&#28155;&#21152;&#21040;typesBySubscriber&#10;    List&#60;Class&#60;?&#62;&#62; subscribedEvents = typesBySubscriber.get(subscriber);&#10;    if (subscribedEvents == null) &#123;&#10;        subscribedEvents = new ArrayList&#60;Class&#60;?&#62;&#62;();&#10;        typesBySubscriber.put(subscriber, subscribedEvents);&#10;    &#125;&#10;    subscribedEvents.add(eventType);&#10;&#10;    // &#22914;&#26524;&#35813;&#20107;&#20214;&#22788;&#29702;&#26041;&#27861;&#20026;&#31896;&#24615;&#20107;&#20214;&#65292;&#21363;&#35774;&#32622;&#20102;&#8220;sticky = true&#8221;&#65292;&#21017;&#38656;&#35201;&#35843;&#29992;checkPostStickyEventToSubscription&#10;    // &#21028;&#26029;&#26159;&#21542;&#26377;&#31896;&#24615;&#20107;&#20214;&#38656;&#35201;&#22788;&#29702;&#65292;&#22914;&#26524;&#38656;&#35201;&#22788;&#29702;&#21017;&#35302;&#21457;&#19968;&#27425;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#10;    if (subscriberMethod.sticky) &#123;&#10;        if (eventInheritance) &#123;&#10;            // Existing sticky events of all subclasses of eventType have to be considered.&#10;            // Note: Iterating over all events may be inefficient with lots of sticky events,&#10;            // thus data structure should be changed to allow a more efficient lookup&#10;            // (e.g. an additional map storing sub classes of super classes: Class -&#62; List&#60;Class&#62;).&#10;            Set&#60;Map.Entry&#60;Class&#60;?&#62;, Object&#62;&#62; entries = stickyEvents.entrySet();&#10;            for (Map.Entry&#60;Class&#60;?&#62;, Object&#62; entry : entries) &#123;&#10;                Class&#60;?&#62; candidateEventType = entry.getKey();&#10;                if (eventType.isAssignableFrom(candidateEventType)) &#123;&#10;                    Object stickyEvent = entry.getValue();&#10;                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);&#10;                &#125;&#10;            &#125;&#10;        &#125; else &#123;&#10;            Object stickyEvent = stickyEvents.get(eventType);&#10;            checkPostStickyEventToSubscription(newSubscription, stickyEvent);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果事件处理函数设置了“sticky = true”，则会调用checkPostStickyEventToSubscription处理粘性事件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;&#10;    if (stickyEvent != null) &#123;&#10;        // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)&#10;        // --&#62; Strange corner case, which we don&#39;t take care of here.&#10;        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在粘性事件，则立即调用postToSubscription触发该事件的事件处理函数。postToSubscription函数后面讲post时会讲到。</p>
<p>至此，整个register过程就介绍完了。<br>总结一下，整个过程分为3步：  </p>
<ol>
<li>查找注册的类中所有的事件处理函数（添加了@Subscribe注解且访问修饰符为public的方法）  </li>
<li>将所有事件处理函数注册到EventBus  </li>
<li>如果有事件处理函数设置了“sticky = true”，则立即处理该事件  </li>
</ol>
<h3 id="post_u4E8B_u4EF6"><a href="#post_u4E8B_u4EF6" class="headerlink" title="post事件"></a>post事件</h3><p>register过程讲完后，我们知道了EventBus如何找到我们定义好的事件处理函数。有了这些事件处理函数，当post相应事件的时候，EventBus就会触发订阅该事件的处理函数。具体post过程是怎样的呢？我们看看代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void post(Object event) &#123;&#10;    PostingThreadState postingState = currentPostingThreadState.get();&#10;    List&#60;Object&#62; eventQueue = postingState.eventQueue;&#10;    eventQueue.add(event);&#10;&#10;    if (!postingState.isPosting) &#123;&#10;        // &#26631;&#35782;post&#30340;&#32447;&#31243;&#26159;&#21542;&#26159;&#20027;&#32447;&#31243;&#10;        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();&#10;        postingState.isPosting = true;&#10;        if (postingState.canceled) &#123;&#10;            throw new EventBusException(&#34;Internal error. Abort state was not reset&#34;);&#10;        &#125;&#10;        try &#123;&#10;            // &#24490;&#29615;&#22788;&#29702;eventQueue&#20013;&#30340;&#27599;&#19968;&#20010;event&#23545;&#35937;&#10;            while (!eventQueue.isEmpty()) &#123;&#10;                postSingleEvent(eventQueue.remove(0), postingState);&#10;            &#125;&#10;        &#125; finally &#123;&#10;            // &#22788;&#29702;&#23436;&#20043;&#21518;&#37325;&#32622;postingState&#30340;&#19968;&#20123;&#26631;&#35782;&#20449;&#24687;&#10;            postingState.isPosting = false;&#10;            postingState.isMainThread = false;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>currentPostingThreadState是一个ThreadLocal类型，里面存储了PostingThreadState；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final ThreadLocal&#60;PostingThreadState&#62; currentPostingThreadState = new ThreadLocal&#60;PostingThreadState&#62;() &#123;&#10;    @Override&#10;    protected PostingThreadState initialValue() &#123;&#10;        return new PostingThreadState();&#10;    &#125;&#10;&#125;;&#10;&#10;/** For ThreadLocal, much faster to set (and get multiple values). */&#10;final static class PostingThreadState &#123;&#10;    final List&#60;Object&#62; eventQueue = new ArrayList&#60;Object&#62;();&#10;    boolean isPosting;&#10;    boolean isMainThread;&#10;    Subscription subscription;&#10;    Object event;&#10;    boolean canceled;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>PostingThreadState包含了一个事件队列eventQueue和一些标志信息。eventQueue存放所有待post的事件对象。</p>
<p>我们再回到post方法，首先会将event对象添加到事件队列eventQueue中。然后判断是否有事件正在post，如果没有则会遍历eventQueue中每一个event对象，并且调用postSingleEvent方法post该事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;&#10;    Class&#60;?&#62; eventClass = event.getClass();&#10;    boolean subscriptionFound = false;&#10;    if (eventInheritance) &#123;&#10;        // &#22914;&#26524;&#20801;&#35768;&#20107;&#20214;&#32487;&#25215;&#65292;&#21017;&#20250;&#35843;&#29992;lookupAllEventTypes&#26597;&#25214;&#25152;&#26377;&#30340;&#29238;&#31867;&#21644;&#25509;&#21475;&#31867;&#10;        List&#60;Class&#60;?&#62;&#62; eventTypes = lookupAllEventTypes(eventClass);&#10;        int countTypes = eventTypes.size();&#10;        for (int h = 0; h &#60; countTypes; h++) &#123;&#10;            Class&#60;?&#62; clazz = eventTypes.get(h);&#10;            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);&#10;        &#125;&#10;    &#125; else &#123;&#10;        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);&#10;    &#125;&#10;    if (!subscriptionFound) &#123;&#10;        if (logNoSubscriberMessages) &#123;&#10;            Log.d(TAG, &#34;No subscribers registered for event &#34; + eventClass);&#10;        &#125;&#10;        if (sendNoSubscriberEvent &#38;&#38; eventClass != NoSubscriberEvent.class &#38;&#38;&#10;                eventClass != SubscriberExceptionEvent.class) &#123;&#10;            // &#22914;&#26524;post&#30340;&#20107;&#20214;&#27809;&#26377;&#34987;&#27880;&#20876;&#65292;&#21017;post&#19968;&#20010;NoSubscriberEvent&#20107;&#20214;&#10;            post(new NoSubscriberEvent(this, event));&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果允许事件继承，则会调用lookupAllEventTypes查找所有的父类和接口类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&#60;Class&#60;?&#62;&#62; lookupAllEventTypes(Class&#60;?&#62; eventClass) &#123;&#10;    synchronized (eventTypesCache) &#123;&#10;        List&#60;Class&#60;?&#62;&#62; eventTypes = eventTypesCache.get(eventClass);&#10;        if (eventTypes == null) &#123;&#10;            eventTypes = new ArrayList&#60;Class&#60;?&#62;&#62;();&#10;            Class&#60;?&#62; clazz = eventClass;&#10;            while (clazz != null) &#123;&#10;                eventTypes.add(clazz);&#10;                addInterfaces(eventTypes, clazz.getInterfaces());&#10;                clazz = clazz.getSuperclass();&#10;            &#125;&#10;            eventTypesCache.put(eventClass, eventTypes);&#10;        &#125;&#10;        return eventTypes;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很简单，就是查找eventClass类的所有父类和接口，并将其保存到eventTypesCache中，方便下次使用。<br>我们再回到postSingleEvent方法。不管允不允许事件继承，都会执行postSingleEventForEventType方法post事件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&#60;?&#62; eventClass) &#123;&#10;    CopyOnWriteArrayList&#60;Subscription&#62; subscriptions;&#10;    synchronized (this) &#123;&#10;        subscriptions = subscriptionsByEventType.get(eventClass);&#10;    &#125;&#10;    if (subscriptions != null &#38;&#38; !subscriptions.isEmpty()) &#123;&#10;        for (Subscription subscription : subscriptions) &#123;&#10;            postingState.event = event;&#10;            postingState.subscription = subscription;&#10;            boolean aborted = false;&#10;            try &#123;&#10;                postToSubscription(subscription, event, postingState.isMainThread);&#10;                aborted = postingState.canceled;&#10;            &#125; finally &#123;&#10;                postingState.event = null;&#10;                postingState.subscription = null;&#10;                postingState.canceled = false;&#10;            &#125;&#10;            if (aborted) &#123;&#10;                break;&#10;            &#125;&#10;        &#125;&#10;        return true;&#10;    &#125;&#10;    return false;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在postSingleEventForEventType方法中，会已eventClass为key从subscriptionsByEventType对象中获取Subscription列表。在上面讲register的时候我们已经看到EventBus在register的时候会将Subscription列表存储在subscriptionsByEventType中。接下来会遍历subscriptions列表然后调用postToSubscription方法进行下一步处理。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;&#10;    switch (subscription.subscriberMethod.threadMode) &#123;&#10;        case PostThread:&#10;            // &#22914;&#26524;&#35813;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#27809;&#26377;&#25351;&#23450;&#32447;&#31243;&#27169;&#22411;&#25110;&#32773;&#32447;&#31243;&#27169;&#22411;&#20026;PostThread&#10;            // &#21017;&#35843;&#29992;invokeSubscriber&#22312;post&#30340;&#32447;&#31243;&#20013;&#25191;&#34892;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#10;            invokeSubscriber(subscription, event);&#10;            break;&#10;        case MainThread:&#10;            // &#22914;&#26524;&#35813;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#25351;&#23450;&#30340;&#32447;&#31243;&#27169;&#22411;&#20026;MainThread&#10;            // &#24182;&#19988;&#24403;&#21069;post&#30340;&#32447;&#31243;&#20026;&#20027;&#32447;&#31243;&#65292;&#21017;&#35843;&#29992;invokeSubscriber&#22312;&#24403;&#21069;&#32447;&#31243;&#65288;&#20027;&#32447;&#31243;&#65289;&#20013;&#25191;&#34892;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#10;            // &#22914;&#26524;post&#30340;&#32447;&#31243;&#19981;&#26159;&#20027;&#32447;&#31243;&#65292;&#23558;&#20351;&#29992;mainThreadPoster.enqueue&#35813;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#28155;&#21152;&#21040;&#20027;&#32447;&#31243;&#30340;&#28040;&#24687;&#38431;&#21015;&#20013;&#10;            if (isMainThread) &#123;&#10;                invokeSubscriber(subscription, event);&#10;            &#125; else &#123;&#10;                mainThreadPoster.enqueue(subscription, event);&#10;            &#125;&#10;            break;&#10;        case BackgroundThread:&#10;            // &#22914;&#26524;&#35813;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#25351;&#23450;&#30340;&#32447;&#31243;&#27169;&#22411;&#20026;BackgroundThread&#10;            // &#24182;&#19988;&#24403;&#21069;post&#30340;&#32447;&#31243;&#20026;&#20027;&#32447;&#31243;&#65292;&#21017;&#35843;&#29992;backgroundPoster.enqueue&#10;            // &#22914;&#26524;post&#30340;&#32447;&#31243;&#19981;&#26159;&#20027;&#32447;&#31243;&#65292;&#21017;&#35843;&#29992;invokeSubscriber&#22312;&#24403;&#21069;&#32447;&#31243;&#65288;&#38750;&#20027;&#32447;&#31243;&#65289;&#20013;&#25191;&#34892;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#10;            if (isMainThread) &#123;&#10;                backgroundPoster.enqueue(subscription, event);&#10;            &#125; else &#123;&#10;                invokeSubscriber(subscription, event);&#10;            &#125;&#10;            break;&#10;        case Async:&#10;            //&#28155;&#21152;&#21040;&#24322;&#27493;&#32447;&#31243;&#38431;&#21015;&#20013;&#10;            asyncPoster.enqueue(subscription, event);&#10;            break;&#10;        default:&#10;            throw new IllegalStateException(&#34;Unknown thread mode: &#34; + subscription.subscriberMethod.threadMode);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法主要是根据register注册的事件处理函数的线程模型在指定的线程中触发事件处理函数。在上一讲<a href="http://liuling123.com/2016/01/EventBus-explain.html" target="_blank" rel="external">EventBus使用详解</a>中已经讲过EventBus的线程模型相关概念了，不明白的可以回去看看。<br>mainThreadPoster、backgroundPoster和asyncPoster分别是HandlerPoster、BackgroundPoster和AsyncPoster的对象，其中HandlerPoster继承自Handle，BackgroundPoster和AsyncPoster继承自Runnable。<br>我们主要看看HandlerPoster。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);</span><br></pre></td></tr></table></figure></p>
<p>在EventBus的构造函数中，我们看到mainThreadPoster初始化的时候，传入的是Looper.getMainLooper()。所以此Handle是运行在主线程中的。<br>mainThreadPoster.enqueue方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void enqueue(Subscription subscription, Object event) &#123;&#10;    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);&#10;    synchronized (this) &#123;&#10;        queue.enqueue(pendingPost);&#10;        if (!handlerActive) &#123;&#10;            handlerActive = true;&#10;            if (!sendMessage(obtainMessage())) &#123;&#10;                throw new EventBusException(&#34;Could not send handler message&#34;);&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>enqueue方法最终会调用sendMessage方法，所以该Handle的handleMessage方法会被调用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public void handleMessage(Message msg) &#123;&#10;    boolean rescheduled = false;&#10;    try &#123;&#10;        long started = SystemClock.uptimeMillis();&#10;        while (true) &#123;&#10;            PendingPost pendingPost = queue.poll();&#10;            if (pendingPost == null) &#123;&#10;                synchronized (this) &#123;&#10;                    // Check again, this time in synchronized&#10;                    pendingPost = queue.poll();&#10;                    if (pendingPost == null) &#123;&#10;                        handlerActive = false;&#10;                        return;&#10;                    &#125;&#10;                &#125;&#10;            &#125;&#10;            eventBus.invokeSubscriber(pendingPost);&#10;            long timeInMethod = SystemClock.uptimeMillis() - started;&#10;            if (timeInMethod &#62;= maxMillisInsideHandleMessage) &#123;&#10;                if (!sendMessage(obtainMessage())) &#123;&#10;                    throw new EventBusException(&#34;Could not send handler message&#34;);&#10;                &#125;&#10;                rescheduled = true;&#10;                return;&#10;            &#125;&#10;        &#125;&#10;    &#125; finally &#123;&#10;        handlerActive = rescheduled;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中，最终还是会调用eventBus.invokeSubscriber调用事件处理函数。</p>
<p>BackgroundPoster和AsyncPoster继承自Runnable，并且会在enqueue方法中调用eventBus.getExecutorService().execute(this);具体run方法大家可以自己去看源码，最终都会调用eventBus.invokeSubscriber方法。我们看看eventBus.invokeSubscriber方法的源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void invokeSubscriber(PendingPost pendingPost) &#123;&#10;    Object event = pendingPost.event;&#10;    Subscription subscription = pendingPost.subscription;&#10;    PendingPost.releasePendingPost(pendingPost);&#10;    if (subscription.active) &#123;&#10;        invokeSubscriber(subscription, event);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法会调用invokeSubscriber方法进一步处理：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void invokeSubscriber(Subscription subscription, Object event) &#123;&#10;    try &#123;&#10;        // &#36890;&#36807;&#21453;&#23556;&#35843;&#29992;&#20107;&#20214;&#22788;&#29702;&#20989;&#25968;&#10;        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);&#10;    &#125; catch (InvocationTargetException e) &#123;&#10;        handleSubscriberException(subscription, event, e.getCause());&#10;    &#125; catch (IllegalAccessException e) &#123;&#10;        throw new IllegalStateException(&#34;Unexpected exception&#34;, e);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法最终会通过反射来调用事件处理函数。至此，整个post过程分析完了。<br>总结一下整个post过程，大致分为3步：  </p>
<ol>
<li>将事件对象添加到事件队列eventQueue中等待处理  </li>
<li>遍历eventQueue队列中的事件对象并调用postSingleEvent处理每个事件  </li>
<li>找出订阅过该事件的所有事件处理函数，并在相应的线程中执行该事件处理函数 </li>
</ol>
<h3 id="u53D6_u6D88_u4E8B_u4EF6_u6CE8_u518C"><a href="#u53D6_u6D88_u4E8B_u4EF6_u6CE8_u518C" class="headerlink" title="取消事件注册"></a>取消事件注册</h3><p>上面已经分析了EventBus的register和post过程，这两个过程是EventBus的核心。不需要订阅事件时需要取消事件注册：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** Unregisters the given subscriber from all event classes. */&#10;public synchronized void unregister(Object subscriber) &#123;&#10;    List&#60;Class&#60;?&#62;&#62; subscribedTypes = typesBySubscriber.get(subscriber);&#10;    if (subscribedTypes != null) &#123;&#10;        for (Class&#60;?&#62; eventType : subscribedTypes) &#123;&#10;            unubscribeByEventType(subscriber, eventType);&#10;        &#125;&#10;        typesBySubscriber.remove(subscriber);&#10;    &#125; else &#123;&#10;        Log.w(TAG, &#34;Subscriber to unregister was not registered before: &#34; + subscriber.getClass());&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>取消事件注册很简单，只是将register过程注册到EventBus的事件处理函数移除掉。</p>
<p>到这里，EventBus源码我们已经分析完了，如有不对的地方还望指点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>前面一篇文章讲解了EventBus的使用，但是作为开发人员，不能只停留在仅仅会用的层面上，我们还需要弄清楚它的内部实现原理。所以本篇博文将分析EventBus的源码，看看究竟它是如何实现“发布/订阅”功能的。</p>
<p>相关文章<br><a href="http://liuling123.com/2016/01/EventBus-explain.html">EventBus使用详解</a><br><a href="http://liuling123.com/2016/01/EventBus-source.html">EventBus源码解析</a></p>
</blockquote>
<h3 id="u4E8B_u4EF6_u6CE8_u518C"><a href="#u4E8B_u4EF6_u6CE8_u518C" class="headerlink" title="事件注册"></a>事件注册</h3><p>根据前一讲<a href="http://liuling123.com/2016/01/EventBus-explain.html">EventBus使用详解</a>我们已经知道EventBus使用首先是需要注册的，注册事件的代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="EventBus" scheme="http://www.liuling123.com/tags/EventBus/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus使用详解]]></title>
    <link href="http://www.liuling123.com/2016/01/EventBus-explain.html"/>
    <id>http://www.liuling123.com/2016/01/EventBus-explain.html</id>
    <published>2016-01-09T04:42:00.000Z</published>
    <updated>2016-01-12T13:33:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>前言：EventBus出来已经有一段时间了，github上面也有很多开源项目中使用了EventBus。所以抽空学习顺便整理了一下。目前EventBus最新版本是3.0，所以本文是基于EventBus3.0的。</p>
<p>相关文章<br><a href="http://liuling123.com/2016/01/EventBus-explain.html" target="_blank" rel="external">EventBus使用详解</a><br><a href="http://liuling123.com/2016/01/EventBus-source.html" target="_blank" rel="external">EventBus源码解析</a></p>
</blockquote>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>是针一款对Android的发布/订阅事件总线。它可以让我们很轻松的实现在Android各个组件之间传递消息，并且代码的可读性更好，耦合度更低。</p>
<a id="more"></a>
<h4 id="u5982_u4F55_u4F7F_u7528"><a href="#u5982_u4F55_u4F7F_u7528" class="headerlink" title="如何使用"></a>如何使用</h4><p>(1)首先需要定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageEvent &#123;&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)在需要订阅事件的地方注册事件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br></pre></td></tr></table></figure></p>
<p>(3)产生事件，即发送消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().post(messageEvent);</span><br></pre></td></tr></table></figure></p>
<p>(4)处理消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.PostThread)&#10;public void XXX(MessageEvent messageEvent) &#123;&#10;    ...&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在3.0之前，EventBus还没有使用注解方式。消息处理的方法也只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，分别代表四种线程模型。而在3.0之后，消息处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为PostThread），四种线程模型，下面会讲到。<br>注意，事件处理函数的访问权限必须为public，否则会报异常。</p>
<p>(5)取消消息订阅<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().unregister(this);</span><br></pre></td></tr></table></figure></p>
<h4 id="u6709_u4F55_u4F18_u70B9"><a href="#u6709_u4F55_u4F18_u70B9" class="headerlink" title="有何优点"></a>有何优点</h4><p>采用消息发布/订阅的一个很大的优点就是代码的简洁性，并且能够有效地降低消息发布者和订阅者之间的耦合度。<br>举个例子，比如有两个界面，ActivityA和ActivityB，从ActivityA界面跳转到ActivityB界面后，ActivityB要给ActivityA发送一个消息，ActivityA收到消息后在界面上显示出来。我们最先想到的方法就是使用广播，使用广播实现此需求的代码如下：<br>首先需要在ActivityA中定义一个广播接收器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageBroadcastReceiver extends BroadcastReceiver &#123;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) &#123;&#10;        mMessageView.setText(&#34;Message from SecondActivity:&#34; + intent.getStringExtra(&#34;message&#34;));&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要在onCreate()方法中注册广播接收器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;protected void onCreate(Bundle savedInstanceState) &#123;&#10;    super.onCreate(savedInstanceState);&#10;    setContentView(R.layout.activity_main);&#10;    //&#27880;&#20876;&#20107;&#20214;&#10;    EventBus.getDefault().register(this);&#10;    //&#27880;&#20876;&#24191;&#25773;&#10;    IntentFilter intentFilter = new IntentFilter(&#34;message_broadcast&#34;);&#10;    mBroadcastReceiver = new MessageBroadcastReceiver();&#10;    registerReceiver(mBroadcastReceiver, intentFilter);&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在onDestory()方法中取消注册广播接收器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;protected void onDestroy() &#123;&#10;    super.onDestroy();&#10;    ......&#10;    //&#21462;&#28040;&#24191;&#25773;&#27880;&#20876;&#10;    unregisterReceiver(mBroadcastReceiver);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们需要在ActivityB界面中发送广播消息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send_broadcast).setOnClickListener(new View.OnClickListener() &#123;&#10;    @Override&#10;    public void onClick(View v) &#123;&#10;        String message = mMessageET.getText().toString();&#10;        if(TextUtils.isEmpty(message)) &#123;&#10;            message = &#34;defaule message&#34;;&#10;        &#125;&#10;        Intent intent = new Intent();&#10;        intent.setAction(&#34;message_broadcast&#34;);&#10;        intent.putExtra(&#34;message&#34;, message);&#10;        sendBroadcast(intent);&#10;    &#125;&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>看着上面的实现代码，感觉也没什么不妥，挺好的！下面对比看下使用EventBus如何实现。<br>根据文章最前面所讲的EventBus使用步骤，首先我们需要定义一个消息事件类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageEvent &#123;&#10;&#10;    private String message;&#10;&#10;    public MessageEvent(String message) &#123;&#10;        this.message = message;&#10;    &#125;&#10;&#10;    public String getMessage() &#123;&#10;        return message;&#10;    &#125;&#10;&#10;    public void setMessage(String message) &#123;&#10;        this.message = message;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在ActivityA界面中我们首先需要注册订阅事件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;protected void onCreate(Bundle savedInstanceState) &#123;&#10;    super.onCreate(savedInstanceState);&#10;    setContentView(R.layout.activity_main);&#10;    //&#27880;&#20876;&#20107;&#20214;&#10;    EventBus.getDefault().register(this);&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在onDestory()方法中取消订阅：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;protected void onDestroy() &#123;&#10;    super.onDestroy();&#10;    //&#21462;&#28040;&#20107;&#20214;&#27880;&#20876;&#10;    EventBus.getDefault().unregister(this);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然还要定义一个消息处理的方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MainThread)&#10;public void onShowMessageEvent(MessageEvent messageEvent) &#123;&#10;    mMessageView.setText(&#34;Message from SecondActivity:&#34; + messageEvent.getMessage());&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，消息订阅者我们已经定义好了，我们还需要在ActivityB中发布消息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(new View.OnClickListener() &#123;&#10;    @Override&#10;    public void onClick(View v) &#123;&#10;        String message = mMessageET.getText().toString();&#10;        if(TextUtils.isEmpty(message)) &#123;&#10;            message = &#34;defaule message&#34;;&#10;        &#125;&#10;        EventBus.getDefault().post(new MessageEvent(message));&#10;    &#125;&#10;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对比代码一看，有人会说了，这尼玛有什么区别嘛！说好的简洁呢？哥们，别着急嘛！我这里只是举了个简单的例子，仅仅从该例子来看，EventBus的优势没有体现出来。现在我将需求稍微改一下，ActivityA收到消息后，需要从网络服务器获取数据并将数据展示出来。如果使用广播，ActivityA中广播接收器代码应该这么写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageBroadcastReceiver extends BroadcastReceiver &#123;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) &#123;&#10;        new Thread(new Runnable() &#123;&#10;            @Override&#10;            public void run() &#123;&#10;                //&#20174;&#26381;&#21153;&#22120;&#19978;&#33719;&#21462;&#25968;&#25454;&#10;                ......&#10;                runOnUiThread(new Runnable() &#123;&#10;                    @Override&#10;                    public void run() &#123;&#10;                        //&#23558;&#33719;&#21462;&#30340;&#25968;&#25454;&#23637;&#31034;&#22312;&#30028;&#38754;&#19978;&#10;                        ......&#10;                    &#125;&#10;                &#125;);&#10;            &#125;&#10;        &#125;).start();&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这段代码，不知道你何感想，反正我是看着很不爽，嵌套层次太多，完全违反了Clean Code的原则。那使用EventBus来实现又是什么样呢？我们看一下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.BackgroundThread)&#10;public void onGetDataEvent(MessageEvent messageEvent) &#123;&#10;    //&#20174;&#26381;&#21153;&#22120;&#19978;&#33719;&#21462;&#25968;&#25454;&#10;    ......&#10;    EventBus.getDefault().post(new ShowMessageEvent());&#10;&#125;&#10;&#10;@Subscribe(threadMode = ThreadMode.MainThread)&#10;public void onShowDataEvent(ShowMessageEvent showMessageEvent) &#123;&#10;    //&#23558;&#33719;&#21462;&#30340;&#25968;&#25454;&#23637;&#31034;&#22312;&#30028;&#38754;&#19978;&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比一下以上两段代码就能很明显的感觉到EventBus的优势，代码简洁、层次清晰，大大提高了代码的可读性和可维护性。我这只是简单的加了一个小需求而已，随着业务越来越复杂，使用EventBus的优势愈加明显。</p>
<h3 id="u5E38_u7528API_u4ECB_u7ECD"><a href="#u5E38_u7528API_u4ECB_u7ECD" class="headerlink" title="常用API介绍"></a>常用API介绍</h3><h4 id="u7EBF_u7A0B_u6A21_u578B"><a href="#u7EBF_u7A0B_u6A21_u578B" class="headerlink" title="线程模型"></a>线程模型</h4><p>在EventBus的事件处理函数中需要指定线程模型，即指定事件处理函数运行所在的想线程。在上面我们已经接触到了EventBus的四种线程模型。那他们有什么区别呢？<br>在EventBus中的观察者通常有四种线程模型，分别是PostThread（默认）、MainThread、BackgroundThread与Async。</p>
<ul>
<li>PostThread：如果使用事件处理函数指定了线程模型为PostThread，那么该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在线程模型为PostThread的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引起ANR。</li>
<li>MainThread：如果使用事件处理函数指定了线程模型为MainThread，那么不论事件是在哪个线程中发布出来的，该事件处理函数都会在UI线程中执行。该方法可以用来更新UI，但是不能处理耗时操作。</li>
<li>BackgroundThread：如果使用事件处理函数指定了线程模型为BackgroundThread，那么如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件处理函数中禁止进行UI更新操作。</li>
<li>Async：如果使用事件处理函数指定了线程模型为Async，那么无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行。同样，此事件处理函数中禁止进行UI更新操作。</li>
</ul>
<p>为了验证以上四个方法，我写了个小例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.PostThread)&#10;public void onMessageEventPostThread(MessageEvent messageEvent) &#123;&#10;    Log.e(&#34;PostThread&#34;, Thread.currentThread().getName());&#10;&#125;&#10;&#10;@Subscribe(threadMode = ThreadMode.MainThread)&#10;public void onMessageEventMainThread(MessageEvent messageEvent) &#123;&#10;    Log.e(&#34;MainThread&#34;, Thread.currentThread().getName());&#10;&#125;&#10;&#10;@Subscribe(threadMode = ThreadMode.BackgroundThread)&#10;public void onMessageEventBackgroundThread(MessageEvent messageEvent) &#123;&#10;    Log.e(&#34;BackgroundThread&#34;, Thread.currentThread().getName());&#10;&#125;&#10;&#10;@Subscribe(threadMode = ThreadMode.Async)&#10;public void onMessageEventAsync(MessageEvent messageEvent) &#123;&#10;    Log.e(&#34;Async&#34;, Thread.currentThread().getName());&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别使用上面四个方法订阅同一事件，打印他们运行所在的线程。首先我们在UI线程中发布一条MessageEvent的消息，看下日志打印结果是什么。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(new View.OnClickListener() &#123;&#10;        @Override&#10;        public void onClick(View v) &#123;&#10;            Log.e(&#34;postEvent&#34;, Thread.currentThread().getName());&#10;            EventBus.getDefault().post(new MessageEvent());&#10;        &#125;&#10;    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>打印结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2689-2689/com.lling.eventbusdemo E/postEvent&#65109; main&#10;2689-2689/com.lling.eventbusdemo E/PostThread&#65109; main&#10;2689-3064/com.lling.eventbusdemo E/Async&#65109; pool-1-thread-1&#10;2689-2689/com.lling.eventbusdemo E/MainThread&#65109; main&#10;2689-3065/com.lling.eventbusdemo E/BackgroundThread&#65109; pool-1-thread-2</span><br></pre></td></tr></table></figure></p>
<p>从日志打印结果可以看出，如果在UI线程中发布事件，则线程模型为PostThread的事件处理函数也执行在UI线程，与发布事件的线程一致。线程模型为Async的事件处理函数执行在名字叫做pool-1-thread-1的新的线程中。而MainThread的事件处理函数执行在UI线程，BackgroundThread的时间处理函数执行在名字叫做pool-1-thread-2的新的线程中。</p>
<p>我们再看看在子线程中发布一条MessageEvent的消息时，会有什么样的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(new View.OnClickListener() &#123;&#10;        @Override&#10;        public void onClick(View v) &#123;&#10;            new Thread(new Runnable() &#123;&#10;                @Override&#10;                public void run() &#123;&#10;                    Log.e(&#34;postEvent&#34;, Thread.currentThread().getName());&#10;                    EventBus.getDefault().post(new MessageEvent());&#10;                &#125;&#10;            &#125;).start();&#10;        &#125;&#10;    &#125;);</span><br></pre></td></tr></table></figure>
<p>打印结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3468-3945/com.lling.eventbusdemo E/postEvent&#65109; Thread-125&#10;3468-3945/com.lling.eventbusdemo E/PostThread&#65109; Thread-125&#10;3468-3945/com.lling.eventbusdemo E/BackgroundThread&#65109; Thread-125&#10;3468-3946/com.lling.eventbusdemo E/Async&#65109; pool-1-thread-1&#10;3468-3468/com.lling.eventbusdemo E/MainThread&#65109; main</span><br></pre></td></tr></table></figure></p>
<p>从日志打印结果可以看出，如果在子线程中发布事件，则线程模型为PostThread的事件处理函数也执行在子线程，与发布事件的线程一致（都是Thread-125）。BackgroundThread事件模型也与发布事件在同一线程执行。Async则在一个名叫pool-1-thread-1的新线程中执行。MainThread还是在UI线程中执行。</p>
<p>上面一个例子充分验证了指定不同线程模型的事件处理方法执行所在的线程。</p>
<h4 id="u9ECF_u6027_u4E8B_u4EF6"><a href="#u9ECF_u6027_u4E8B_u4EF6" class="headerlink" title="黏性事件"></a>黏性事件</h4><p>除了上面讲的普通事件外，EventBus还支持发送黏性事件。何为黏性事件呢？简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。具体用法如下：</p>
<p>订阅黏性事件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(StickyModeActivity.this);</span><br></pre></td></tr></table></figure></p>
<p>黏性事件处理函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe(sticky = true)&#10;public void XXX(MessageEvent messageEvent) &#123;&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送黏性事件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(new MessageEvent(&#34;test&#34;));</span><br></pre></td></tr></table></figure></p>
<p>处理消息事件以及取消订阅和上面方式相同。</p>
<p>看个简单的黏性事件的例子，为了简单起见我这里就在一个Activity里演示了。</p>
<p>Activity代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StickyModeActivity extends AppCompatActivity &#123;&#10;&#10;    int index = 0;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) &#123;&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_sticky_mode);&#10;        findViewById(R.id.post).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View v) &#123;&#10;                EventBus.getDefault().postSticky(new MessageEvent(&#34;test&#34; + index++));&#10;            &#125;&#10;        &#125;);&#10;        findViewById(R.id.regist).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View v) &#123;&#10;                EventBus.getDefault().registerSticky(StickyModeActivity.this);&#10;            &#125;&#10;        &#125;);&#10;&#10;        findViewById(R.id.unregist).setOnClickListener(new View.OnClickListener() &#123;&#10;            @Override&#10;            public void onClick(View v) &#123;&#10;                EventBus.getDefault().unregister(StickyModeActivity.this);&#10;            &#125;&#10;        &#125;);&#10;&#10;    &#125;&#10;&#10;    @Subscribe(threadMode = ThreadMode.PostThread, sticky = true)&#10;    public void onMessageEventPostThread(MessageEvent messageEvent) &#123;&#10;        Log.e(&#34;PostThread&#34;, messageEvent.getMessage());&#10;    &#125;&#10;&#10;    @Subscribe(threadMode = ThreadMode.MainThread, sticky = true)&#10;    public void onMessageEventMainThread(MessageEvent messageEvent) &#123;&#10;        Log.e(&#34;MainThread&#34;, messageEvent.getMessage());&#10;    &#125;&#10;&#10;    @Subscribe(threadMode = ThreadMode.BackgroundThread, sticky = true)&#10;    public void onMessageEventBackgroundThread(MessageEvent messageEvent) &#123;&#10;        Log.e(&#34;BackgroundThread&#34;, messageEvent.getMessage());&#10;    &#125;&#10;&#10;    @Subscribe(threadMode = ThreadMode.Async, sticky = true)&#10;    public void onMessageEventAsync(MessageEvent messageEvent) &#123;&#10;        Log.e(&#34;Async&#34;, messageEvent.getMessage());&#10;    &#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>布局代码activity_sticky_mode.xml：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&#10;    xmlns:tools=&#34;http://schemas.android.com/tools&#34; android:layout_width=&#34;match_parent&#34;&#10;    android:layout_height=&#34;match_parent&#34; android:paddingLeft=&#34;@dimen/activity_horizontal_margin&#34;&#10;    android:paddingRight=&#34;@dimen/activity_horizontal_margin&#34;&#10;    android:paddingTop=&#34;@dimen/activity_vertical_margin&#34;&#10;    android:paddingBottom=&#34;@dimen/activity_vertical_margin&#34;&#10;    android:orientation=&#34;vertical&#34;&#10;    tools:context=&#34;com.lling.eventbusdemo.StickyModeActivity&#34;&#62;&#10;&#10;    &#60;Button&#10;        android:id=&#34;@+id/post&#34;&#10;        android:layout_width=&#34;wrap_content&#34;&#10;        android:layout_height=&#34;wrap_content&#34;&#10;        android:text=&#34;Post&#34;/&#62;&#10;&#10;    &#60;Button&#10;        android:id=&#34;@+id/regist&#34;&#10;        android:layout_width=&#34;wrap_content&#34;&#10;        android:layout_height=&#34;wrap_content&#34;&#10;        android:text=&#34;Regist&#34;/&#62;&#10;&#10;    &#60;Button&#10;        android:id=&#34;@+id/unregist&#34;&#10;        android:layout_width=&#34;wrap_content&#34;&#10;        android:layout_height=&#34;wrap_content&#34;&#10;        android:text=&#34;UnRegist&#34;/&#62;&#10;&#10;&#60;/LinearLayout&#62;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单，界面上三个按钮，一个用来发送黏性事件，一个用来订阅事件，还有一个用来取消订阅的。首先在未订阅的情况下点击发送按钮发送一个黏性事件，然后点击订阅，会看到日志打印结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15246-15246/com.lling.eventbusdemo E/PostThread&#65109; test0&#10;15246-15391/com.lling.eventbusdemo E/Async&#65109; test0&#10;15246-15246/com.lling.eventbusdemo E/MainThread&#65109; test0&#10;15246-15393/com.lling.eventbusdemo E/BackgroundThread&#65109; test0</span><br></pre></td></tr></table></figure></p>
<p>这就是粘性事件，能够收到订阅之前发送的消息。但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。这个我们可以验证一下，我们连续点击5次POST按钮发送5条黏性事件，然后再点击REGIST按钮订阅，打印结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6980-6980/com.lling.eventbusdemo E/PostThread&#65109; test4&#10;6980-6980/com.lling.eventbusdemo E/MainThread&#65109; test4&#10;6980-7049/com.lling.eventbusdemo E/Async&#65109; test4&#10;6980-7048/com.lling.eventbusdemo E/BackgroundThread&#65109; test4</span><br></pre></td></tr></table></figure></p>
<p>由打印结果可以看出，确实是只收到最近的一条黏性事件。</p>
<p>好了，EventBus的使用暂时分析到这里，例子代码<a href="https://github.com/liuling07/EventBusDemo" target="_blank" rel="external">从这里获取</a>。下一讲将讲解<a href="http://liuling123.com/2016/01/EventBus-source.html" target="_blank" rel="external">EventBus源码解析</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>前言：EventBus出来已经有一段时间了，github上面也有很多开源项目中使用了EventBus。所以抽空学习顺便整理了一下。目前EventBus最新版本是3.0，所以本文是基于EventBus3.0的。</p>
<p>相关文章<br><a href="http://liuling123.com/2016/01/EventBus-explain.html">EventBus使用详解</a><br><a href="http://liuling123.com/2016/01/EventBus-source.html">EventBus源码解析</a></p>
</blockquote>
<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p><a href="https://github.com/greenrobot/EventBus">EventBus</a>是针一款对Android的发布/订阅事件总线。它可以让我们很轻松的实现在Android各个组件之间传递消息，并且代码的可读性更好，耦合度更低。</p>]]>
    
    </summary>
    
      <category term="EventBus" scheme="http://www.liuling123.com/tags/EventBus/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译文】AppBarLayout的越界滚动行为]]></title>
    <link href="http://www.liuling123.com/2016/01/overscroll-appBarLayout-behavior.html"/>
    <id>http://www.liuling123.com/2016/01/overscroll-appBarLayout-behavior.html</id>
    <published>2016-01-03T14:03:00.000Z</published>
    <updated>2016-01-03T14:08:49.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/@nullthemall/overscroll-appbarlayout-behavior-e58f1ee2807#.gtmxsk7sw" target="_blank" rel="external">Overscroll AppBarLayout Behavior</a></li>
<li>原文作者 : <a href="https://medium.com/@nullthemall" target="_blank" rel="external">Nikola Despotoski</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn。未经允许，不得转载!</a></li>
<li>译者 : <a href="https://github.com/liuling07" target="_blank" rel="external">liuling07</a> </li>
<li>校对者: <a href="https://github.com/desmond1121" target="_blank" rel="external">desmond1121</a></li>
<li>状态 :  完成 </li>
</ul>
</blockquote>
<p>很不幸，Youtube音乐应用在我们国家不可使用，我尝试着通过各种盗版网站来获取该应用，但我仍然无法看到在这个应用上发生了什么。感谢这位<a href="https://www.reddit.com/user/IanSan5653" target="_blank" rel="external">redditor</a>，在我的请求下，他在<a href="https://www.reddit.com/r/materialdesign" target="_blank" rel="external">/r/materialdesign</a>打开了一个<a href="https://www.reddit.com/r/MaterialDesign/comments/3slct5/youtube_music_has_tons_of_animations_and/" target="_blank" rel="external">thread</a>并且发表一段录制的视频，我才有机会看到这个行为。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*lEMS5RiBLGk3Q72FhXBwxA.gif" alt="Youtube视频app的真实截图，可能的行为"></p>
<a id="more"></a>
<p>根据我所看到的，我首先想到的就是专辑封面是放到一个AppBarLayout里面，并且在滚动区域拖到边界的时候尺寸会发生变化。让我们假定这个猜想是正确的并且用“Behavior”这个术语表示它。依鄙人之见，如果我的猜想是正确的，谷歌应该会在Material Design文档的<a href="https://www.google.com/design/spec/patterns/scrolling-techniques.html" target="_blank" rel="external">滚动</a>部分提供一个越界滚动的使用说明。</p>
<p>我们的目标就是保证AppBarLayout.Behavior的完整性，在此基础上再创建一个扩展的行为。因此：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OverscrollScalingViewAppBarLayoutBehavior extends AppBarLayout.ScrollingViewBehavior</span><br></pre></td></tr></table></figure>
<p>因为这是默认的AppBarLayout.Behavior，所以建议只有在依赖视图是AppBarLayout的时候起作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123;&#10; return dependency instanceof AppBarLayout;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要获取想要在拖到边界时要改变尺寸的视图的一个实例。最好的方法就是在onLayoutChild()方法中获取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public boolean onLayoutChild(CoordinatorLayout parent ....) &#123;&#10;    boolean superLayout = super.onLayoutChild(parent, abl, layoutDirection);&#10;    if (mTargetScalingView == null) &#123;&#10;        mTargetScalingView = parent.findViewByTag(TAG);&#10;        if(mTargetScalingView != null)&#123;&#10;             mScaleImpl.obtainInitialValues();&#10;         &#125;&#10;     &#125;&#10;    return superLayout;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>而且我们需要保证只有在垂直滚动的时候起作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout,... int nestedScrollAxes) &#123;&#10;    return nestedScrollAxes == View.SCROLL_AXIS_VERTICAL;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们先前没有在程序中显示设置，会设置ViewScaler为默认的Scaler。</p>
<p>在内容滚动的瞬间，真正重要的问题就有头绪了。CoordinatorLayout.Behavior提供了一个onNestedScroll()方法，当滚动进行的时候这个方法会被调用，并且当内容滚动到边界的时候也会调用。最后两个参数dyUnconsumed和dxUnconsumed提供了未被该行为的目标视图填满的像素值。</p>
<p>这个方法对我们实现尺寸改变来说太重要了。所以我列出了哪些情况需要改变尺寸，哪些情况不需要：</p>
<h4 id="u9700_u8981_u6539_u53D8_u5C3A_u5BF8"><a href="#u9700_u8981_u6539_u53D8_u5C3A_u5BF8" class="headerlink" title="需要改变尺寸"></a>需要改变尺寸</h4><ol>
<li>存在未填满的像素，如dyUnconsumed小于0  </li>
<li>AppBarLayout是展开的，getTopAndBottomOffset() &gt;= mScaleImpl.getInitialParentBottom()</li>
</ol>
<h4 id="u4E0D_u9700_u8981_u6539_u53D8_u5C3A_u5BF8"><a href="#u4E0D_u9700_u8981_u6539_u53D8_u5C3A_u5BF8" class="headerlink" title="不需要改变尺寸"></a>不需要改变尺寸</h4><ol>
<li>AppBarLayout中没有子视图可以改变尺寸</li>
<li>有填充的像素，如dyConsumed不等于0</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public void onNestedScroll(CoordinatorLayout ... int dxUnconsumed, int dyUnconsumed) &#123;&#10;    if (mTargetScalingView == null || dyConsumed != 0) &#123;&#10;        mScaleImpl.cancelAnimations();&#10;        super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);&#10;        return;&#10;    &#125;&#10;&#10;    if (dyUnconsumed &#60; 0 &#38;&#38; getTopAndBottomOffset() &#62;= mScaleImpl.getInitialParentBottom()) &#123;&#10;        int absDyUnconsumed = Math.abs(dyUnconsumed);&#10;        mTotalDyUnconsumed += absDyUnconsumed;&#10;        mTotalDyUnconsumed = Math.min(mTotalDyUnconsumed, mTotalTargetDyUnconsumed);&#10;        mScaleImpl.updateViewScale();&#10;    &#125; else &#123;&#10;        mTotalDyUnconsumed = 0;&#10;        mScaleImpl.setShouldRestore(false);&#10;        if (dyConsumed != 0) &#123;&#10;            mScaleImpl.cancelAnimations();&#10;        &#125;&#10;        super.onNestedScroll(coordinatorLayout, .... dxUnconsumed, dyUnconsumed);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当嵌套的overscroll停止的时候，我们需要将视图的边界和大小重置到它们的原始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target) &#123;&#10;    mScaleImpl.retractScale();&#10;    super.onStopNestedScroll(coordinatorLayout, child, target);&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ViewScaler"><a href="#ViewScaler" class="headerlink" title="ViewScaler"></a>ViewScaler</h1><p>这个类实现了AppBarLayout应该如何改变它的底部以及视图应该如何改变尺寸的逻辑。大多数行为都依赖累积的未填充的像素。我们可以为最大累积值设置一个约束值，这样可以很容的找到要如何改变AppBarLayout底部和改变视图的尺寸。ParentScaler是ViewScaler的父类，它能让AppBarLayout近乎平滑的改变尺寸。我就不在这里贴大量代码了，如果你有兴趣，<a href="https://gist.github.com/NikolaDespotoski/7d6a019e5aafe60ebade" target="_blank" rel="external">可以从这里获取代码</a>。</p>
<h4 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h4><p>大神们，这里有个MatrixScaler类，我没有时间去完成它。如果想要改变尺寸的视图是ImageView，并且设置了ScaleType为MATRIX，这个类将可以用使用矩阵的方式来改变图像的尺寸。  </p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://youtu.be/2udXoC8AXSM" target="_blank" rel="external">Demo演示地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/@nullthemall/overscroll-appbarlayout-behavior-e58f1ee2807#.gtmxsk7sw">Overscroll AppBarLayout Behavior</a></li>
<li>原文作者 : <a href="https://medium.com/@nullthemall">Nikola Despotoski</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn。未经允许，不得转载!</a></li>
<li>译者 : <a href="https://github.com/liuling07">liuling07</a> </li>
<li>校对者: <a href="https://github.com/desmond1121">desmond1121</a></li>
<li>状态 :  完成 </li>
</ul>
</blockquote>
<p>很不幸，Youtube音乐应用在我们国家不可使用，我尝试着通过各种盗版网站来获取该应用，但我仍然无法看到在这个应用上发生了什么。感谢这位<a href="https://www.reddit.com/user/IanSan5653">redditor</a>，在我的请求下，他在<a href="https://www.reddit.com/r/materialdesign">/r/materialdesign</a>打开了一个<a href="https://www.reddit.com/r/MaterialDesign/comments/3slct5/youtube_music_has_tons_of_animations_and/">thread</a>并且发表一段录制的视频，我才有机会看到这个行为。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*lEMS5RiBLGk3Q72FhXBwxA.gif" alt="Youtube视频app的真实截图，可能的行为"></p>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="译文" scheme="http://www.liuling123.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Say bye to my 2015]]></title>
    <link href="http://www.liuling123.com/2015/12/Say-bye-to-my-2015.html"/>
    <id>http://www.liuling123.com/2015/12/Say-bye-to-my-2015.html</id>
    <published>2015-12-25T09:25:10.000Z</published>
    <updated>2016-01-03T06:52:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6280_u672F_u6210_u957F"><a href="#u6280_u672F_u6210_u957F" class="headerlink" title="技术成长"></a><strong>技术成长</strong></h2><p>14年毕业后开始接触Android，到目前为止从事Android开发差不多一年半的时间，15年算是自己技术成长最大的一年吧。<br>上半年自己大部分精力都耗在云老师项目上，自己既要开发同时兼任项目负责人（这里要感谢老大认可，愿意给新人机会）。前前后后经历了四五次迭代，最终在3个Android新人（确切来说是两个）的努力下完成并上线了。遗憾的是项目不受公司重视，并且部门领导担心影响实体产品的销售而不愿推广。最后随着部门的解散该项目也夭折了，这当时对我来说是很令人伤心的事了。虽然项目夭折了，但是自己从中收获了不少。不仅是技术水平的提升，还收获了项目管理的经验。 </p>
<p>部门解散前，有一个多月时间是比较闲的。利用这段时间自己研究了Android Framework层的源码，搭建了自己的<a href="http://www.liuling123.com/">个人技术博客</a>并且接触了开源社区github。贡献了图片选择库<a href="https://github.com/liuling07/PhotoPicker" target="_blank" rel="external">PhotoPicker</a>。<br>部门解散后，到新部门做cocos2dx游戏开发，学习了C++以及cocos2dx引擎。利用下班在家的时间学习了Material Design等知识，并且开发了基于Material Design和MVP模式的新闻客户端<a href="https://github.com/liuling07/SimpleNews" target="_blank" rel="external">SimpleNews</a>。</p>
<a id="more"></a>
<h2 id="u8BFB_u4E66"><a href="#u8BFB_u4E66" class="headerlink" title="读书"></a><strong>读书</strong></h2><p>今年看的书不多，看完的有《代码整洁之道》、《极客与团队》、《微管理》、《拆掉思维里的墙》  </p>
<p>未看完的有《从0到1》、《C++ Primer》、《cocos2dX高级开发教程》。</p>
<h2 id="u57F9_u8BAD"><a href="#u57F9_u8BAD" class="headerlink" title="培训"></a><strong>培训</strong></h2><p>今年公司组织两场培训，刘捷老师的《Clean Code》以及MSUP软件工作坊培训。两场培训下来收获都挺大的，尤其是刘捷老师的《Clean Code》课程，培训完之后立马现学现用，为小组制定Android编码规范并且实施代码review。</p>
<h2 id="u953B_u70BC"><a href="#u953B_u70BC" class="headerlink" title="锻炼"></a><strong>锻炼</strong></h2><p>最为程序员，长期坐在电脑前作业，如果没有锻炼的习惯，恐怕身体很难扛得住。自己不爱跑步，对健身房也没兴趣，只喜欢约上几个好友在球场挥洒汗水。</p>
<p>因为鼻骨被撞骨折，14年下半年一直没有碰球，15年春节过后伤好又开始坚持打球了。基本上每周三晚上都和同事在篮球公园包场打。后来部门解散，同事回总部的回总部，离职的离职，最后篮球活动也取消了。之后就每周日早上和同学在宝体打，一直坚持到现在。</p>
<h2 id="15_u5E74_u5927_u4E8B_u8BB0"><a href="#15_u5E74_u5927_u4E8B_u8BB0" class="headerlink" title="15年大事记"></a><strong>15年大事记</strong></h2><p>第一次去女朋友家里，并商讨婚嫁事宜，这算是我人生中一件大事了吧。  </p>
<p>下了血本买了台中配Mac pro。对于生产工具一定要买所能承受范围内最好的。  </p>
<p>搭建自己的<a href="http://www.liuling123.com/">个人技术博客</a>，并且开始接触开源社区，并在github和微博上关注了很多业界大牛。</p>
<h2 id="16_u5E74_u5C55_u671B"><a href="#16_u5E74_u5C55_u671B" class="headerlink" title="16年展望"></a><strong>16年展望</strong></h2><p>首先得找一份自己满意的Android研发工作，因为自己对游戏开发（儿童游戏，略感弱智）没有太大兴趣；  </p>
<p>努力提升自己的技术水平，向业界大牛靠拢；  </p>
<p>多向github贡献代码，经常更新自己的技术博客；  </p>
<p>看完Simple哥送的《Android软件安全与逆向分析》（感谢Simple哥 <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">@bboyfeiyu</a> ）,看完徐医生的《Android群英传》； </p>
<p>和女朋友订婚；</p>
<p><a href="https://github.com/winter-fall/Bye2015Hi2016/issues/30" target="_blank" rel="external">https://github.com/winter-fall/Bye2015Hi2016/issues/30</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6280_u672F_u6210_u957F"><a href="#u6280_u672F_u6210_u957F" class="headerlink" title="技术成长"></a><strong>技术成长</strong></h2><p>14年毕业后开始接触Android，到目前为止从事Android开发差不多一年半的时间，15年算是自己技术成长最大的一年吧。<br>上半年自己大部分精力都耗在云老师项目上，自己既要开发同时兼任项目负责人（这里要感谢老大认可，愿意给新人机会）。前前后后经历了四五次迭代，最终在3个Android新人（确切来说是两个）的努力下完成并上线了。遗憾的是项目不受公司重视，并且部门领导担心影响实体产品的销售而不愿推广。最后随着部门的解散该项目也夭折了，这当时对我来说是很令人伤心的事了。虽然项目夭折了，但是自己从中收获了不少。不仅是技术水平的提升，还收获了项目管理的经验。 </p>
<p>部门解散前，有一个多月时间是比较闲的。利用这段时间自己研究了Android Framework层的源码，搭建了自己的<a href="http://www.liuling123.com/">个人技术博客</a>并且接触了开源社区github。贡献了图片选择库<a href="https://github.com/liuling07/PhotoPicker">PhotoPicker</a>。<br>部门解散后，到新部门做cocos2dx游戏开发，学习了C++以及cocos2dx引擎。利用下班在家的时间学习了Material Design等知识，并且开发了基于Material Design和MVP模式的新闻客户端<a href="https://github.com/liuling07/SimpleNews">SimpleNews</a>。</p>]]>
    
    </summary>
    
      <category term="人生感悟" scheme="http://www.liuling123.com/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MVP模式在Android项目中的使用]]></title>
    <link href="http://www.liuling123.com/2015/12/mvp-pattern-android.html"/>
    <id>http://www.liuling123.com/2015/12/mvp-pattern-android.html</id>
    <published>2015-12-23T14:16:04.000Z</published>
    <updated>2016-01-03T07:35:27.000Z</updated>
    <content type="html"><![CDATA[<p> 以前在写项目的时候，没有过多考虑架构模式的问题，因为之前一直做J2EE开发，而J2EE都是采用MVC模式进行开发的，所以在搭建公司项目的时候，也是使用类似MVC的架构（严格来讲，之前的项目还算不上MVC模式，只是简单将网络请求与界面分离，然后通过Handle通知更新界面）。这种写法，在后面随着项目越来越大，Activty或者Fragment中代码也会越来越多，导致项目的维护变的越来越复杂。所以需要另外一种架构模式来解决这个问题，在网上浏览了一圈，发现适合Android开发的架构模式非MVP莫属了。</p>
<p>网上一搜，讲MVP模式的文章比比皆是。但是大多都是讲理论，稍微好点的会附带一个简单的登录的demo。一个简单的demo很难让初次接触MVP模式的人掌握它的使用。所以我决定写一个稍微复杂一点的新闻客户端SimpleNews（当然只是相对登录的demo）来展示MVP在具体项目中的使用。另外SimpleNews还使用了Material Design，也是学习Material Design的一个好Demo。<br><a id="more"></a><br>好了，切入正文吧。先讲一下MVP的概念。</p>
<h3 id="u4EC0_u4E48_u662FMVP"><a href="#u4EC0_u4E48_u662FMVP" class="headerlink" title="什么是MVP"></a>什么是MVP</h3><p>MVP是模型（Model）、视图（View）、主持人（Presenter）的缩写，分别代表项目中3个不同的模块。</p>
<ul>
<li><p>模型（Model）：负责处理数据的加载或者存储，比如从网络或本地数据库获取数据等；</p>
</li>
<li><p>视图（View）：负责界面数据的展示，与用户进行交互；</p>
</li>
<li><p>主持人（Presenter）：相当于协调者，是模型与视图之间的桥梁，将模型与视图分离开来。</p>
</li>
</ul>
<p>如下图所示，View与Model并不直接交互，而是使用Presenter作为View与Model之间的桥梁。其中Presenter中同时持有Viwe层以及Model层的Interface的引用，而View层持有Presenter层Interface的引用。当View层某个界面需要展示某些数据的时候，首先会调用Presenter层的某个接口，然后Presenter层会调用Model层请求数据，当Model层数据加载成功之后会调用Presenter层的回调方法通知Presenter层数据加载完毕，最后Presenter层再调用View层的接口将加载后的数据展示给用户。这就是MVP模式的整个核心过程。<br><img src="http://7xnqm4.com1.z0.glb.clouddn.com/Android中MVP的使用%C2%8F%C2%9B.png" alt="MVP模式"></p>
<p>这样分层的好处就是大大减少了Model与View层之间的耦合度。一方面可以使得View层和Model层单独开发与测试，互不依赖。另一方面Model层可以封装复用，可以极大的减少代码量。当然，MVP还有其他的一些优点，这里不再赘述。下面看下MVP模式在具体项目中的使用。</p>
<h3 id="MVP_u6A21_u5F0F_u5728_u9879_u76EE_u4E2D_u7684_u4F7F_u7528"><a href="#MVP_u6A21_u5F0F_u5728_u9879_u76EE_u4E2D_u7684_u4F7F_u7528" class="headerlink" title="MVP模式在项目中的使用"></a>MVP模式在项目中的使用</h3><h4 id="View_u5C42"><a href="#View_u5C42" class="headerlink" title="View层"></a>View层</h4><p>View层新闻展示模块的是组件是Fragment，里面有一个RecyclerView、SwipeRefreshLayout。布局代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&#62;&#10;&#60;android.support.v4.widget.SwipeRefreshLayout&#10;    xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&#10;    xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;&#10;    android:id=&#34;@+id/swipe_refresh_widget&#34;&#10;    android:layout_width=&#34;match_parent&#34;&#10;    android:layout_height=&#34;match_parent&#34;&#62;&#10;    &#60;android.support.v7.widget.RecyclerView&#10;        android:id=&#34;@+id/recycle_view&#34;&#10;        android:layout_width=&#34;match_parent&#34;&#10;        android:layout_height=&#34;wrap_content&#34;&#10;        android:scrollbars=&#34;vertical&#34;&#10;        app:layout_behavior=&#34;@string/appbar_scrolling_view_behavior&#34;&#10;        android:paddingTop=&#34;@dimen/card_margin&#34;&#62;&#10;    &#60;/android.support.v7.widget.RecyclerView&#62;&#10;&#60;/android.support.v4.widget.SwipeRefreshLayout&#62;</span><br></pre></td></tr></table></figure>
<p>新闻列表模块主要是展示从网络获取的新闻列表信息，View层的接口大概需要如下方法：</p>
<ol>
<li>加载数据的过程中需要提示“正在加载”的反馈信息给用户</li>
<li>加载成功后，将加载得到的数据填充到RecyclerView展示给用户</li>
<li>加载成功后，需要将“正在加载”反馈信息取消掉</li>
<li>若加载数据失败，如无网络连接，则需要给用户提示信息</li>
</ol>
<p>根据上面描述，我们将View层的接口定义如下，分别对应上面四个方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface NewsView &#123;&#10;    void showProgress();&#10;    void addNews(List&#60;NewsBean&#62; newsList);&#10;    void hideProgress();&#10;    void showLoadFailMsg();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在新闻列表Fragment中实现上述接口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.lauren.simplenews.news.widget;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.support.annotation.Nullable;&#10;import android.support.design.widget.Snackbar;&#10;import android.support.v4.app.ActivityCompat;&#10;import android.support.v4.app.ActivityOptionsCompat;&#10;import android.support.v4.app.Fragment;&#10;import android.support.v4.widget.SwipeRefreshLayout;&#10;import android.support.v7.widget.DefaultItemAnimator;&#10;import android.support.v7.widget.LinearLayoutManager;&#10;import android.support.v7.widget.RecyclerView;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import com.lauren.simplenews.R;&#10;import com.lauren.simplenews.beans.NewsBean;&#10;import com.lauren.simplenews.commons.Urls;&#10;import com.lauren.simplenews.news.NewsAdapter;&#10;import com.lauren.simplenews.news.presenter.NewsPresenter;&#10;import com.lauren.simplenews.news.presenter.NewsPresenterImpl;&#10;import com.lauren.simplenews.news.view.NewsView;&#10;import com.lauren.simplenews.utils.LogUtils;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;/**&#10; * Description : &#26032;&#38395;Fragment&#10; * Author : lauren&#10; * Email  : lauren.liuling@gmail.com&#10; * Blog   : http://www.liuling123.com&#10; * Date   : 15/12/13&#10; */&#10;public class NewsListFragment extends Fragment implements NewsView, SwipeRefreshLayout.OnRefreshListener &#123;&#10;    private static final String TAG = &#34;NewsListFragment&#34;;&#10;    private SwipeRefreshLayout mSwipeRefreshWidget;&#10;    private RecyclerView mRecyclerView;&#10;    private LinearLayoutManager mLayoutManager;&#10;    private NewsAdapter mAdapter;&#10;    private List&#60;NewsBean&#62; mData;&#10;    private NewsPresenter mNewsPresenter;&#10;    private int mType = NewsFragment.NEWS_TYPE_TOP;&#10;    private int pageIndex = 0;&#10;    public static NewsListFragment newInstance(int type) &#123;&#10;        Bundle args = new Bundle();&#10;        NewsListFragment fragment = new NewsListFragment();&#10;        args.putInt(&#34;type&#34;, type);&#10;        fragment.setArguments(args);&#10;        return fragment;&#10;    &#125;&#10;    @Override&#10;    public void onCreate(@Nullable Bundle savedInstanceState) &#123;&#10;        super.onCreate(savedInstanceState);&#10;        mNewsPresenter = new NewsPresenterImpl(this);&#10;        mType = getArguments().getInt(&#34;type&#34;);&#10;    &#125;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;&#10;        View view = inflater.inflate(R.layout.fragment_newslist, null);&#10;        mSwipeRefreshWidget = (SwipeRefreshLayout) view.findViewById(R.id.swipe_refresh_widget);&#10;        mSwipeRefreshWidget.setColorSchemeResources(R.color.primary,&#10;                R.color.primary_dark, R.color.primary_light,&#10;                R.color.accent);&#10;        mSwipeRefreshWidget.setOnRefreshListener(this);&#10;        mRecyclerView = (RecyclerView)view.findViewById(R.id.recycle_view);&#10;        mRecyclerView.setHasFixedSize(true);&#10;        mLayoutManager = new LinearLayoutManager(getActivity());&#10;        mRecyclerView.setLayoutManager(mLayoutManager);&#10;        mRecyclerView.setItemAnimator(new DefaultItemAnimator());&#10;        mAdapter = new NewsAdapter(getActivity().getApplicationContext());&#10;        mAdapter.setOnItemClickListener(mOnItemClickListener);&#10;        mRecyclerView.setAdapter(mAdapter);&#10;        mRecyclerView.setOnScrollListener(mOnScrollListener);&#10;        onRefresh();&#10;        return view;&#10;    &#125;&#10;    private RecyclerView.OnScrollListener mOnScrollListener = new RecyclerView.OnScrollListener() &#123;&#10;        private int lastVisibleItem;&#10;        @Override&#10;        public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123;&#10;            super.onScrolled(recyclerView, dx, dy);&#10;            lastVisibleItem = mLayoutManager.findLastVisibleItemPosition();&#10;        &#125;&#10;        @Override&#10;        public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123;&#10;            super.onScrollStateChanged(recyclerView, newState);&#10;            if (newState == RecyclerView.SCROLL_STATE_IDLE&#10;                    &#38;&#38; lastVisibleItem + 1 == mAdapter.getItemCount()&#10;                    &#38;&#38; mAdapter.isShowFooter()) &#123;&#10;                //&#21152;&#36733;&#26356;&#22810;&#10;                LogUtils.d(TAG, &#34;loading more data&#34;);&#10;                mNewsPresenter.loadNews(mType, pageIndex + Urls.PAZE_SIZE);&#10;            &#125;&#10;        &#125;&#10;    &#125;;&#10;    private NewsAdapter.OnItemClickListener mOnItemClickListener = new NewsAdapter.OnItemClickListener() &#123;&#10;        @Override&#10;        public void onItemClick(View view, int position) &#123;&#10;            NewsBean news = mAdapter.getItem(position);&#10;            Intent intent = new Intent(getActivity(), NewsDetailActivity.class);&#10;            intent.putExtra(&#34;news&#34;, news);&#10;            View transitionView = view.findViewById(R.id.ivNews);&#10;            ActivityOptionsCompat options =&#10;                    ActivityOptionsCompat.makeSceneTransitionAnimation(getActivity(),&#10;                            transitionView, getString(R.string.transition_news_img));&#10;            ActivityCompat.startActivity(getActivity(), intent, options.toBundle());&#10;        &#125;&#10;    &#125;;&#10;    @Override&#10;    public void showProgress() &#123;&#10;        mSwipeRefreshWidget.setRefreshing(true);&#10;    &#125;&#10;    @Override&#10;    public void addNews(List&#60;NewsBean&#62; newsList) &#123;&#10;        mAdapter.isShowFooter(true);&#10;        if(mData == null) &#123;&#10;            mData = new ArrayList&#60;NewsBean&#62;();&#10;        &#125;&#10;        mData.addAll(newsList);&#10;        if(pageIndex == 0) &#123;&#10;            mAdapter.setmDate(mData);&#10;        &#125; else &#123;&#10;            //&#22914;&#26524;&#27809;&#26377;&#26356;&#22810;&#25968;&#25454;&#20102;,&#21017;&#38544;&#34255;footer&#24067;&#23616;&#10;            if(newsList == null || newsList.size() == 0) &#123;&#10;                mAdapter.isShowFooter(false);&#10;            &#125;&#10;            mAdapter.notifyDataSetChanged();&#10;        &#125;&#10;        pageIndex += Urls.PAZE_SIZE;&#10;    &#125;&#10;    @Override&#10;    public void hideProgress() &#123;&#10;        mSwipeRefreshWidget.setRefreshing(false);&#10;    &#125;&#10;    @Override&#10;    public void showLoadFailMsg() &#123;&#10;        if(pageIndex == 0) &#123;&#10;            mAdapter.isShowFooter(false);&#10;            mAdapter.notifyDataSetChanged();&#10;        &#125;&#10;        Snackbar.make(getActivity().findViewById(R.id.drawer_layout), getString(R.string.load_fail), Snackbar.LENGTH_SHORT).show();&#10;    &#125;&#10;    @Override&#10;    public void onRefresh() &#123;&#10;        pageIndex = 0;&#10;        if(mData != null) &#123;&#10;            mData.clear();&#10;        &#125;&#10;        mNewsPresenter.loadNews(mType, pageIndex);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Model_u5C42"><a href="#Model_u5C42" class="headerlink" title="Model层"></a>Model层</h4><p>新闻模块的model主要负责从服务器获取新闻列表信息，接口代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface NewsModel &#123;&#10;    void loadNews(String url, int type, NewsModelImpl.OnLoadNewsListListener listener);&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.lauren.simplenews.news.model;&#10;import com.lauren.simplenews.beans.NewsBean;&#10;import com.lauren.simplenews.beans.NewsDetailBean;&#10;import com.lauren.simplenews.commons.Urls;&#10;import com.lauren.simplenews.news.NewsJsonUtils;&#10;import com.lauren.simplenews.news.widget.NewsFragment;&#10;import com.lauren.simplenews.utils.OkHttpUtils;&#10;import java.util.List;&#10;/**&#10; * Description : &#26032;&#38395;&#19994;&#21153;&#22788;&#29702;&#31867;&#10; * Author : lauren&#10; * Email  : lauren.liuling@gmail.com&#10; * Blog   : http://www.liuling123.com&#10; * Date   : 15/12/19&#10; */&#10;public class NewsModelImpl implements NewsModel &#123;&#10;    /**&#10;     * &#21152;&#36733;&#26032;&#38395;&#21015;&#34920;&#10;     * @param url&#10;     * @param listener&#10;     */&#10;    @Override&#10;    public void loadNews(String url, final int type, final OnLoadNewsListListener listener) &#123;&#10;        OkHttpUtils.ResultCallback&#60;String&#62; loadNewsCallback = new OkHttpUtils.ResultCallback&#60;String&#62;() &#123;&#10;            @Override&#10;            public void onSuccess(String response) &#123;&#10;                List&#60;NewsBean&#62; newsBeanList = NewsJsonUtils.readJsonNewsBeans(response, getID(type));&#10;                listener.onSuccess(newsBeanList);&#10;            &#125;&#10;            @Override&#10;            public void onFailure(Exception e) &#123;&#10;                listener.onFailure(&#34;load news list failure.&#34;, e);&#10;            &#125;&#10;        &#125;;&#10;        OkHttpUtils.get(url, loadNewsCallback);&#10;    &#125;&#10;    ......&#10;    /**&#10;     * &#33719;&#21462;ID&#10;     * @param type&#10;     * @return&#10;     */&#10;    private String getID(int type) &#123;&#10;        String id;&#10;        switch (type) &#123;&#10;            case NewsFragment.NEWS_TYPE_TOP:&#10;                id = Urls.TOP_ID;&#10;                break;&#10;            case NewsFragment.NEWS_TYPE_NBA:&#10;                id = Urls.NBA_ID;&#10;                break;&#10;            case NewsFragment.NEWS_TYPE_CARS:&#10;                id = Urls.CAR_ID;&#10;                break;&#10;            case NewsFragment.NEWS_TYPE_JOKES:&#10;                id = Urls.JOKE_ID;&#10;                break;&#10;            default:&#10;                id = Urls.TOP_ID;&#10;                break;&#10;        &#125;&#10;        return id;&#10;    &#125;&#10;    private String getDetailUrl(String docId) &#123;&#10;        StringBuffer sb = new StringBuffer(Urls.NEW_DETAIL);&#10;        sb.append(docId).append(Urls.END_DETAIL_URL);&#10;        return sb.toString();&#10;    &#125;&#10;    public interface OnLoadNewsListListener &#123;&#10;        void onSuccess(List&#60;NewsBean&#62; list);&#10;        void onFailure(String msg, Exception e);&#10;    &#125;&#10;    ......&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>网络请求使用开源项目OkHttp，OkHttpUtils是对其的封装，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.lauren.simplenews.utils;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import com.google.gson.internal.$Gson$Types;&#10;import com.squareup.okhttp.Callback;&#10;import com.squareup.okhttp.FormEncodingBuilder;&#10;import com.squareup.okhttp.OkHttpClient;&#10;import com.squareup.okhttp.Request;&#10;import com.squareup.okhttp.RequestBody;&#10;import com.squareup.okhttp.Response;&#10;import java.io.IOException;&#10;import java.lang.reflect.ParameterizedType;&#10;import java.lang.reflect.Type;&#10;import java.net.CookieManager;&#10;import java.net.CookiePolicy;&#10;import java.util.List;&#10;import java.util.concurrent.TimeUnit;&#10;/**&#10; * Description : OkHttp&#32593;&#32476;&#36830;&#25509;&#23553;&#35013;&#24037;&#20855;&#31867;&#10; * Author : lauren&#10; * Email  : lauren.liuling@gmail.com&#10; * Blog   : http://www.liuling123.com&#10; * Date   : 15/12/17&#10; */&#10;public class OkHttpUtils &#123;&#10;    private static final String TAG = &#34;OkHttpUtils&#34;;&#10;    private static OkHttpUtils mInstance;&#10;    private OkHttpClient mOkHttpClient;&#10;    private Handler mDelivery;&#10;    private OkHttpUtils() &#123;&#10;        mOkHttpClient = new OkHttpClient();&#10;        mOkHttpClient.setConnectTimeout(10, TimeUnit.SECONDS);&#10;        mOkHttpClient.setWriteTimeout(10, TimeUnit.SECONDS);&#10;        mOkHttpClient.setReadTimeout(30, TimeUnit.SECONDS);&#10;        //cookie enabled&#10;        mOkHttpClient.setCookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ORIGINAL_SERVER));&#10;        mDelivery = new Handler(Looper.getMainLooper());&#10;    &#125;&#10;    private synchronized static OkHttpUtils getmInstance() &#123;&#10;        if (mInstance == null) &#123;&#10;            mInstance = new OkHttpUtils();&#10;        &#125;&#10;        return mInstance;&#10;    &#125;&#10;    private void getRequest(String url, final ResultCallback callback) &#123;&#10;        final Request request = new Request.Builder().url(url).build();&#10;        deliveryResult(callback, request);&#10;    &#125;&#10;    private void postRequest(String url, final ResultCallback callback, List&#60;Param&#62; params) &#123;&#10;        Request request = buildPostRequest(url, params);&#10;        deliveryResult(callback, request);&#10;    &#125;&#10;    private void deliveryResult(final ResultCallback callback, Request request) &#123;&#10;        mOkHttpClient.newCall(request).enqueue(new Callback() &#123;&#10;            @Override&#10;            public void onFailure(Request request, final IOException e) &#123;&#10;                sendFailCallback(callback, e);&#10;            &#125;&#10;            @Override&#10;            public void onResponse(Response response) throws IOException &#123;&#10;                try &#123;&#10;                    String str = response.body().string();&#10;                    if (callback.mType == String.class) &#123;&#10;                        sendSuccessCallBack(callback, str);&#10;                    &#125; else &#123;&#10;                        Object object = JsonUtils.deserialize(str, callback.mType);&#10;                        sendSuccessCallBack(callback, object);&#10;                    &#125;&#10;                &#125; catch (final Exception e) &#123;&#10;                    LogUtils.e(TAG, &#34;convert json failure&#34;, e);&#10;                    sendFailCallback(callback, e);&#10;                &#125;&#10;            &#125;&#10;        &#125;);&#10;    &#125;&#10;    private void sendFailCallback(final ResultCallback callback, final Exception e) &#123;&#10;        mDelivery.post(new Runnable() &#123;&#10;            @Override&#10;            public void run() &#123;&#10;                if (callback != null) &#123;&#10;                    callback.onFailure(e);&#10;                &#125;&#10;            &#125;&#10;        &#125;);&#10;    &#125;&#10;    private void sendSuccessCallBack(final ResultCallback callback, final Object obj) &#123;&#10;        mDelivery.post(new Runnable() &#123;&#10;            @Override&#10;            public void run() &#123;&#10;                if (callback != null) &#123;&#10;                    callback.onSuccess(obj);&#10;                &#125;&#10;            &#125;&#10;        &#125;);&#10;    &#125;&#10;    private Request buildPostRequest(String url, List&#60;Param&#62; params) &#123;&#10;        FormEncodingBuilder builder = new FormEncodingBuilder();&#10;        for (Param param : params) &#123;&#10;            builder.add(param.key, param.value);&#10;        &#125;&#10;        RequestBody requestBody = builder.build();&#10;        return new Request.Builder().url(url).post(requestBody).build();&#10;    &#125;&#10;    /**********************&#23545;&#22806;&#25509;&#21475;************************/&#10;    /**&#10;     * get&#35831;&#27714;&#10;     * @param url  &#35831;&#27714;url&#10;     * @param callback  &#35831;&#27714;&#22238;&#35843;&#10;     */&#10;    public static void get(String url, ResultCallback callback) &#123;&#10;        getmInstance().getRequest(url, callback);&#10;    &#125;&#10;    /**&#10;     * post&#35831;&#27714;&#10;     * @param url       &#35831;&#27714;url&#10;     * @param callback  &#35831;&#27714;&#22238;&#35843;&#10;     * @param params    &#35831;&#27714;&#21442;&#25968;&#10;     */&#10;    public static void post(String url, final ResultCallback callback, List&#60;Param&#62; params) &#123;&#10;        getmInstance().postRequest(url, callback, params);&#10;    &#125;&#10;    /**&#10;     * http&#35831;&#27714;&#22238;&#35843;&#31867;,&#22238;&#35843;&#26041;&#27861;&#22312;UI&#32447;&#31243;&#20013;&#25191;&#34892;&#10;     * @param &#60;T&#62;&#10;     */&#10;    public static abstract class ResultCallback&#60;T&#62; &#123;&#10;        Type mType;&#10;        public ResultCallback()&#123;&#10;            mType = getSuperclassTypeParameter(getClass());&#10;        &#125;&#10;        static Type getSuperclassTypeParameter(Class&#60;?&#62; subclass) &#123;&#10;            Type superclass = subclass.getGenericSuperclass();&#10;            if (superclass instanceof Class) &#123;&#10;                throw new RuntimeException(&#34;Missing type parameter.&#34;);&#10;            &#125;&#10;            ParameterizedType parameterized = (ParameterizedType) superclass;&#10;            return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);&#10;        &#125;&#10;        /**&#10;         * &#35831;&#27714;&#25104;&#21151;&#22238;&#35843;&#10;         * @param response&#10;         */&#10;        public abstract void onSuccess(T response);&#10;        /**&#10;         * &#35831;&#27714;&#22833;&#36133;&#22238;&#35843;&#10;         * @param e&#10;         */&#10;        public abstract void onFailure(Exception e);&#10;    &#125;&#10;    /**&#10;     * post&#35831;&#27714;&#21442;&#25968;&#31867;&#10;     */&#10;    public static class Param &#123;&#10;        String key;&#10;        String value;&#10;        public Param() &#123;&#10;        &#125;&#10;        public Param(String key, String value) &#123;&#10;            this.key = key;&#10;            this.value = value;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>将网络请求进行封装可以减少很多的代码量，并且后期如果我不想用okhttp了，想换成其它的库，修改起来也方便。</p>
<h4 id="Presenter_u5C42"><a href="#Presenter_u5C42" class="headerlink" title="Presenter层"></a>Presenter层</h4><p>View层需要调用Presenter层加载新闻信息，所以Presenter需要提供加载新闻信息的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface NewsPresenter &#123;&#10;    void loadNews(int type, int page);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>NewsPresenterImpl的构造函数中需要传入View层的接口对象NewView，并且需要创建一个NewsModel对象。Presenter的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.lauren.simplenews.news.presenter;&#10;import com.lauren.simplenews.beans.NewsBean;&#10;import com.lauren.simplenews.commons.Urls;&#10;import com.lauren.simplenews.news.model.NewsModel;&#10;import com.lauren.simplenews.news.model.NewsModelImpl;&#10;import com.lauren.simplenews.news.view.NewsView;&#10;import com.lauren.simplenews.news.widget.NewsFragment;&#10;import com.lauren.simplenews.utils.LogUtils;&#10;import java.util.List;&#10;/**&#10; * Description :&#10; * Author : lauren&#10; * Email  : lauren.liuling@gmail.com&#10; * Blog   : http://www.liuling123.com&#10; * Date   : 15/12/18&#10; */&#10;public class NewsPresenterImpl implements NewsPresenter, NewsModelImpl.OnLoadNewsListListener &#123;&#10;    private static final String TAG = &#34;NewsPresenterImpl&#34;;&#10;    private NewsView mNewsView;&#10;    private NewsModel mNewsModel;&#10;    public NewsPresenterImpl(NewsView newsView) &#123;&#10;        this.mNewsView = newsView;&#10;        this.mNewsModel = new NewsModelImpl();&#10;    &#125;&#10;    @Override&#10;    public void loadNews(final int type, final int pageIndex) &#123;&#10;        String url = getUrl(type, pageIndex);&#10;        LogUtils.d(TAG, url);&#10;        //&#21482;&#26377;&#31532;&#19968;&#39029;&#30340;&#25110;&#32773;&#21047;&#26032;&#30340;&#26102;&#20505;&#25165;&#26174;&#31034;&#21047;&#26032;&#36827;&#24230;&#26465;&#10;        if(pageIndex == 0) &#123;&#10;            mNewsView.showProgress();&#10;        &#125;&#10;        mNewsModel.loadNews(url, type, this);&#10;    &#125;&#10;    /**&#10;     * &#26681;&#25454;&#31867;&#21035;&#21644;&#39029;&#38754;&#32034;&#24341;&#21019;&#24314;url&#10;     * @param type&#10;     * @param pageIndex&#10;     * @return&#10;     */&#10;    private String getUrl(int type, int pageIndex) &#123;&#10;        StringBuffer sb = new StringBuffer();&#10;        switch (type) &#123;&#10;            case NewsFragment.NEWS_TYPE_TOP:&#10;                sb.append(Urls.TOP_URL).append(Urls.TOP_ID);&#10;                break;&#10;            case NewsFragment.NEWS_TYPE_NBA:&#10;                sb.append(Urls.COMMON_URL).append(Urls.NBA_ID);&#10;                break;&#10;            case NewsFragment.NEWS_TYPE_CARS:&#10;                sb.append(Urls.COMMON_URL).append(Urls.CAR_ID);&#10;                break;&#10;            case NewsFragment.NEWS_TYPE_JOKES:&#10;                sb.append(Urls.COMMON_URL).append(Urls.JOKE_ID);&#10;                break;&#10;            default:&#10;                sb.append(Urls.TOP_URL).append(Urls.TOP_ID);&#10;                break;&#10;        &#125;&#10;        sb.append(&#34;/&#34;).append(pageIndex).append(Urls.END_URL);&#10;        return sb.toString();&#10;    &#125;&#10;    @Override&#10;    public void onSuccess(List&#60;NewsBean&#62; list) &#123;&#10;        mNewsView.hideProgress();&#10;        mNewsView.addNews(list);&#10;    &#125;&#10;    @Override&#10;    public void onFailure(String msg, Exception e) &#123;&#10;        mNewsView.hideProgress();&#10;        mNewsView.showLoadFailMsg();&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>当用户切换到NewsListFragment界面之后，界面需要展示新闻列表信息给用户。首先NewsListFragment会调用NewsPresenter的loadNews方法，NewsPresenter 的loadNews方法中又会调用NewsModel中的loadNews方法。NewsModel中的loadNews方法中就是加载数据的核心，通过Okhttp请求服务器接口获取数据，无论数据获取成功与否，都会通过OnLoadNewsListener接口回调给NewsPresenter 。如果获取成功，NewsPresenter 会调用NewsView的addNews方法将获取的新闻列表信息展示到RecyclerView。如果获取失败，则调用NewsView的showLoadFialMsg方法向用户提示失败信息。</p>
<p>以上就是新闻列表请求的整个过程。</p>
<p>源码地址：<a href="https://github.com/liuling07/SimpleNews" target="_blank" rel="external">https://github.com/liuling07/SimpleNews</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 以前在写项目的时候，没有过多考虑架构模式的问题，因为之前一直做J2EE开发，而J2EE都是采用MVC模式进行开发的，所以在搭建公司项目的时候，也是使用类似MVC的架构（严格来讲，之前的项目还算不上MVC模式，只是简单将网络请求与界面分离，然后通过Handle通知更新界面）。这种写法，在后面随着项目越来越大，Activty或者Fragment中代码也会越来越多，导致项目的维护变的越来越复杂。所以需要另外一种架构模式来解决这个问题，在网上浏览了一圈，发现适合Android开发的架构模式非MVP莫属了。</p>
<p>网上一搜，讲MVP模式的文章比比皆是。但是大多都是讲理论，稍微好点的会附带一个简单的登录的demo。一个简单的demo很难让初次接触MVP模式的人掌握它的使用。所以我决定写一个稍微复杂一点的新闻客户端SimpleNews（当然只是相对登录的demo）来展示MVP在具体项目中的使用。另外SimpleNews还使用了Material Design，也是学习Material Design的一个好Demo。<br>]]>
    
    </summary>
    
      <category term="MVP" scheme="http://www.liuling123.com/tags/MVP/"/>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="设计模式" scheme="http://www.liuling123.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译文】Android M中Intent的解析]]></title>
    <link href="http://www.liuling123.com/2015/12/intent-resolving-in-android-m.html"/>
    <id>http://www.liuling123.com/2015/12/intent-resolving-in-android-m.html</id>
    <published>2015-12-04T06:52:06.000Z</published>
    <updated>2016-01-03T07:29:56.000Z</updated>
    <content type="html"><![CDATA[<p>原文链接 : <a href="https://medium.com/google-developer-experts/intent-resolving-in-android-m-c17d39d27048#.n23z2g14e" target="_blank" rel="external">Intent Resolving in Android M</a><br>原文作者 : <a href="https://medium.com/@tasomaniac" target="_blank" rel="external">Said Tahsin Dane</a><br>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn。未经允许，不得转载!</a><br>译者 : <a href="https://github.com/liuling07" target="_blank" rel="external">liuling07</a><br>校对者: <a href="https://github.com/desmond1121" target="_blank" rel="external">desmond1121</a><br>状态 : 完成</p>
<h2 id="u8BD1_u6587_u8FDE_u63A5_uFF1AAndroid_M_u4E2DIntent_u7684_u89E3_u6790"><a href="#u8BD1_u6587_u8FDE_u63A5_uFF1AAndroid_M_u4E2DIntent_u7684_u89E3_u6790" class="headerlink" title="译文连接：Android M中Intent的解析"></a>译文连接：<a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/others/Android-M中Intent的解析" target="_blank" rel="external">Android M中Intent的解析</a></h2><p>注意了！在Android 6.0中，“隐式Intent”的解析不能像之前版本那样正常工作了。这很有可能导致你的app不能正常使用。</p>
<p>现在让我解释一下这个意料之中的问题以及为什么它不能正常使用： 最近，我正在开发一个小的开源项目，叫做“Open Link With”。希望不久后它能够在应用市场上架。</p>
<p>我的这个app能够让你在其他app之间随意切换。当你给我分享一个链接的时候，我基本上可以根据这个链接查询出所有可以处理这个链接的Activity。然后我会模拟一个系统对话框让你切换app。<br><a id="more"></a><br><img src="https://cdn-images-1.medium.com/max/1600/1*rW8I8aCpJ2q8fnfKH_51_g.gif" alt="从已经打开的youtube的web页面切换到youtube应用" title="从已经打开的youtube的web页面切换到youtube应用"></p>
<p>我一直都是使用下面的方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&#60;ResolveInfo&#62; infos = packageManager&#10;        .queryIntentActivities(intent, MATCH_DEFAULT_ONLY);</span><br></pre></td></tr></table></figure></p>
<p>这段代码几乎所有Android开发者都比较熟悉，并且我也相信大部分app都有用到这段代码。</p>
<p>我的手机里有两个浏览器。“一个URL是Google+ 的Intent”期望得到一个具有3个ResolveInfo对象的列表（Google+应用以及两个浏览器）。</p>
<p>好吧，并不是这样！</p>
<p>欢迎来到Android 6.0！</p>
<p>Android 6.0引进了应用关联。系统主要通过你的web页面来认证，并且自动使用你的app来打开这些URL，而不会向你做任何请求。或者你可以到系统设置，选择“应用程序”，然后点击一个应用，再点击“默认打开方式”，然后设置“用这个应用打开”，就可以每次都使用这个应用打开。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*MVZbYKhwu-7qnyGAFWuNsw.png" alt="Android 6.0的应用默认设置页面" title="Android 6.0的应用默认设置页面"></p>
<p>在这种情况下，queryIntentActivities方法只会给开发者返回一个只有一个Activity的列表（此例子返回的是Google+）。</p>
<p>虽然这是在意料之中的，但是应该在文档中注明，因为它与公共API相矛盾了。</p>
<p>我研究了一下，发现了一个MATCH_ALL标志，文档表示，它将禁用所有的系统级过滤器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**&#10; * Querying flag: if set and if the platform is doing any filtering of the results, then&#10; * the filtering will not happen. This is a synonym for saying that all results should&#10; * be returned.&#10; */&#10;public static final int MATCH_ALL = 0x00020000;</span><br></pre></td></tr></table></figure>
<p>这对我来说没什么用。我打开源码（至少我有源码）并开始研究这个方法。</p>
<p>它似乎优先考虑验证应用程序的域，不仅在它的内部系统，在公共API中也是如此。</p>
<p>如果有一个验证应用程序的域，它不会返回任何其他东西。MATCH_ALL标志会移除一些系统过滤器，但是仅仅是在没有验证程序的情况下。</p>
<p>对于这个问题，我找不到任何可变通的措施。它只是排除浏览器应用，即使他们的IntentFilters匹配。</p>
<p>之所以没有可变通的措施，是因为他是一个内部组件（我们无法访问），Android SDK通过IPC使用AIDL与它进行通信。</p>
<p>大部分开发者使用这个方法来判断是否至少有一个Activity来处理隐式的Intent。在大多数情况下，列表中第一项就是你想要的。</p>
<p>在花了几个小时搞明白到底发生了什么之后，我尝试寻找一个我认为每个人都应该知道的解决方案。</p>
<p>在Android 6.0中，改动的地方很多。实际上谷歌提供了一些改变清单，在清单中你能看到到底有哪些改变。我认为还有很多类似上面的一些没有在清单中列出的改变，而这些改动很有可能导致你的应用无法正常运行。</p>
<p>所以如果你使用PackageManager的方法，你一定得小心，并且认真检查。</p>
<p>感谢此文的校对者：<a href="https://twitter.com/yagmurdalman" target="_blank" rel="external">Yağmur Dalman</a>、<a href="https://medium.com/u/9706138c9bfb" target="_blank" rel="external">Sebastiano Poggi</a>、<a href="https://medium.com/u/73761c65c602" target="_blank" rel="external">Salim KAYABAŞI</a>、<a href="https://medium.com/u/24a0490cd588" target="_blank" rel="external">Hasan Keklik</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接 : <a href="https://medium.com/google-developer-experts/intent-resolving-in-android-m-c17d39d27048#.n23z2g14e">Intent Resolving in Android M</a><br>原文作者 : <a href="https://medium.com/@tasomaniac">Said Tahsin Dane</a><br>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn。未经允许，不得转载!</a><br>译者 : <a href="https://github.com/liuling07">liuling07</a><br>校对者: <a href="https://github.com/desmond1121">desmond1121</a><br>状态 : 完成</p>
<h2 id="u8BD1_u6587_u8FDE_u63A5_uFF1AAndroid_M_u4E2DIntent_u7684_u89E3_u6790"><a href="#u8BD1_u6587_u8FDE_u63A5_uFF1AAndroid_M_u4E2DIntent_u7684_u89E3_u6790" class="headerlink" title="译文连接：Android M中Intent的解析"></a>译文连接：<a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/others/Android-M中Intent的解析">Android M中Intent的解析</a></h2><p>注意了！在Android 6.0中，“隐式Intent”的解析不能像之前版本那样正常工作了。这很有可能导致你的app不能正常使用。</p>
<p>现在让我解释一下这个意料之中的问题以及为什么它不能正常使用： 最近，我正在开发一个小的开源项目，叫做“Open Link With”。希望不久后它能够在应用市场上架。</p>
<p>我的这个app能够让你在其他app之间随意切换。当你给我分享一个链接的时候，我基本上可以根据这个链接查询出所有可以处理这个链接的Activity。然后我会模拟一个系统对话框让你切换app。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="译文" scheme="http://www.liuling123.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译文】高性能ListViews]]></title>
    <link href="http://www.liuling123.com/2015/12/performance-listviews.html"/>
    <id>http://www.liuling123.com/2015/12/performance-listviews.html</id>
    <published>2015-12-02T10:22:14.000Z</published>
    <updated>2016-01-03T07:37:23.000Z</updated>
    <content type="html"><![CDATA[<p>原文链接 : <a href="http://willowtreeapps.com/blog/performance-listviews/?utm_source=Android+Weekly&amp;utm_campaign=038d344835-Android_Weekly_178&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-038d344835-337955857" target="_blank" rel="external">Performance ListViews</a><br>原文作者 : <a href="http://willowtreeapps.com/blog/" target="_blank" rel="external">Brandon</a><br>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn。未经允许，不得转载!</a><br>译者 : <a href="https://github.com/liuling07" target="_blank" rel="external">liuling07</a><br>校对者: <a href="https://github.com/desmond1121" target="_blank" rel="external">desmond1121</a><br>状态 : 完成</p>
<h2 id="u8BD1_u6587_u8FDE_u63A5_uFF1A_u9AD8_u6027_u80FDListViews"><a href="#u8BD1_u6587_u8FDE_u63A5_uFF1A_u9AD8_u6027_u80FDListViews" class="headerlink" title="译文连接：高性能ListViews"></a>译文连接：<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/androidweekly/高性能ListViews/高性能ListViews.md" target="_blank" rel="external">高性能ListViews</a></h2><p>列表展示功能几乎在所有app中都会被用到，使用列表可以很方便的展示一些列表项，比如菜谱、联系人，或者任意类型的类别。所以Android有一个内置的方式来展示此类型的数据，也是在情理之中的。RecyclerView是一种最新的展示列表数据的方式，它非常高效，因为它重用视图而不是每一行出现在屏幕上都重新创建。在RecyclerView出现之前，我们可以使用ListView，即使到了现在，ListView也是广泛的被开发者所使用。虽然ListView也是可以回收视图的，但它也一直都是Android中最容易被错误使用的一个控件。我们知道在此之前这个话题已经被写过无数遍了，但是今天我还是要在博客中提出来，因为我们仍然发现很多app在错误的使用它们。</p>
<p>关于ListView中ArrayAdapter的用法，标准的新手写法是这样子的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public View getView(int position, View convertView, ViewGroup parent) &#123;&#10; &#10;    LayoutInflater inflater = (LayoutInflater) context&#10;            .getSystemService(Context.LAYOUT_INFLATER_SERVICE);&#10;    View rowView = inflater.inflate(R.layout.view_test_row, parent, false);&#10; &#10;    TextView testName = (TextView)rowView.findViewById(R.id.text_view_test_name);&#10;    TextView testDesc = (TextView)rowView.findViewById(R.id.text_view_test_desc);&#10; &#10;    //modify TextViews, in some arbitrary way&#10; &#10;    return rowView;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>当所有列表项都能够一次性在一屏中显示的时候，这种写法并没有什么问题，但这样你就创建了一个基本视图，并完全避免了ArrayAdapter的麻烦了吗？当ListView需要显示一个很大的列表集，而且列表子项是一个非常复杂的视图的时候，上面的方式会消耗大量的性能。当用户滑动屏幕的时候，每个视图都会被inflate并且调用findViewById()方法。当findViewById()方法被调用的时候，会遍历整个视图层级，直到找到正确的Id。每个子视图都要执行上述过程！并且用户滑动的越快，卡顿现象愈加明显。为了解决这个问题，我们可以使用一个静态类来绑定还没被使用的convertView。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class ViewHolder()&#123;&#10; &#10;        TextView testName;&#10;        TextView testDesc;&#10; &#10;&#125;&#10; &#10;@Override&#10; public View getView(int position, View convertView, ViewGroup parent) &#123;&#10; &#10;    View rowView = convertView;  //reference to one of the previous Views in the list that we can reuse.&#10; &#10;    if(convertView == null) &#123;&#10; &#10;        LayoutInflater inflater = (LayoutInflater) context&#10;                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);&#10;        rowView = inflater.inflate(R.layout.view_test_row, parent, false);&#10; &#10;        ViewHolder viewHolder = new ViewHolder();&#10;        viewHolder.testName = (TextView) rowView.findViewById(R.id.text_view_test_name);&#10;        viewHolder.testDesc = (TextView) rowView.findViewById(R.id.text_view_test_desc);&#10; &#10;        rowView.setTag(viewHolder);&#10;    &#125;&#10; &#10;    ViewHolder holder = (ViewHolder) rowView.getTag();&#10; &#10;    //in real code these strings should be in res&#10;    holder.testName.setText(&#34;Test&#34;+position);&#10;    holder.testDesc.setText(&#34;This is number &#34;+position);&#10; &#10;    return rowView;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>那convertView又是什么呢？它可以让ListView跳过一些显示一行内容所需要的设置。如果某一行的视图不在屏幕中显示，我们可以重复使用这个视图来显示一个新行。当ListView刚开始显示的时候，一切都是正常的。既然没有视图可以被用来复用，convertView为空。视图也像前面版本一样被inflate，但是TextViews会被找到且它的引用被保存在一个ViewHolder中。然后我们可以调用setTag()方法将ViewHolder存储在视图中。正如修订过后的getView()方法中后半段代码所示，我们可以在视图中存储后面我们需要用到的数据。</p>
<p>我们所做的更改可能看起来并没有太大的效果，但是随着布局越来越复杂并且数量也越来越多，效果将变得越来越明显。作为开发者，我最不想做的事就是开发一个用户体验很差的app。所以请记住，仅仅一个低水平的ListView都有可能让一个app死掉，我们一定得避免这种情况发生。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接 : <a href="http://willowtreeapps.com/blog/performance-listviews/?utm_source=Android+Weekly&amp;utm_campaign=038d344835-Android_Weekly_178&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-038d344835-337955857">Performance ListViews</a><br>原文作者 : <a href="http://willowtreeapps.com/blog/">Brandon</a><br>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn。未经允许，不得转载!</a><br>译者 : <a href="https://github.com/liuling07">liuling07</a><br>校对者: <a href="https://github.com/desmond1121">desmond1121</a><br>状态 : 完成</p>
<h2 id="u8BD1_u6587_u8FDE_u63A5_uFF1A_u9AD8_u6027_u80FDListViews"><a href="#u8BD1_u6587_u8FDE_u63A5_uFF1A_u9AD8_u6027_u80FDListViews" class="headerlink" title="译文连接：高性能ListViews"></a>译文连接：<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/androidweekly/高性能ListViews/高性能ListViews.md">高性能ListViews</a></h2><p>列表展示功能几乎在所有app中都会被用到，使用列表可以很方便的展示一些列表项，比如菜谱、联系人，或者任意类型的类别。所以Android有一个内置的方式来展示此类型的数据，也是在情理之中的。RecyclerView是一种最新的展示列表数据的方式，它非常高效，因为它重用视图而不是每一行出现在屏幕上都重新创建。在RecyclerView出现之前，我们可以使用ListView，即使到了现在，ListView也是广泛的被开发者所使用。虽然ListView也是可以回收视图的，但它也一直都是Android中最容易被错误使用的一个控件。我们知道在此之前这个话题已经被写过无数遍了，但是今天我还是要在博客中提出来，因为我们仍然发现很多app在错误的使用它们。</p>
<p>关于ListView中ArrayAdapter的用法，标准的新手写法是这样子的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;public View getView(int position, View convertView, ViewGroup parent) &#123;&#10; &#10;    LayoutInflater inflater = (LayoutInflater) context&#10;            .getSystemService(Context.LAYOUT_INFLATER_SERVICE);&#10;    View rowView = inflater.inflate(R.layout.view_test_row, parent, false);&#10; &#10;    TextView testName = (TextView)rowView.findViewById(R.id.text_view_test_name);&#10;    TextView testDesc = (TextView)rowView.findViewById(R.id.text_view_test_desc);&#10; &#10;    //modify TextViews, in some arbitrary way&#10; &#10;    return rowView;&#10;&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="译文" scheme="http://www.liuling123.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android带多选功能的PhotoPicker]]></title>
    <link href="http://www.liuling123.com/2015/11/android-multi-photo-picker.html"/>
    <id>http://www.liuling123.com/2015/11/android-multi-photo-picker.html</id>
    <published>2015-11-21T07:46:03.000Z</published>
    <updated>2016-01-03T07:01:45.000Z</updated>
    <content type="html"><![CDATA[<p>最近利用闲碎的一些时间开发了一个Android库<a href="https://github.com/liuling07/PhotoPicker" target="_blank" rel="external">PhotoPicker</a>，前面一篇文章也介绍了，<a href="http://www.liuling123.com/2015/11/android-photo-picker.html">Android高仿微信图片选择功能的PhotoPicker</a>，之前没有加入选择多张图片的功能，现在加上之后一个完整的PhotoPicker库终于算是完工了。</p>
<h2 id="u52A8_u6001_u6548_u679C_u56FE"><a href="#u52A8_u6001_u6548_u679C_u56FE" class="headerlink" title="动态效果图"></a><strong>动态效果图</strong></h2><p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/photo-picker-sample.gif?watermark/1/image/aHR0cDovLzd4bnFtNC5jb20xLnowLmdsYi5jbG91ZGRuLmNvbS93YXRlcm1hcmsucG5n/dissolve/50/gravity/SouthEast" alt="Android带多选功能的PhotoPicker示例图片" title="Android带多选功能的PhotoPicker示例图片"></p>
<a id="more"></a>
<h2 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><p>引入PhotoPicker库，在需要使用图片选择功能的地方添加如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent = new Intent(MainActivity.this, PhotoPickerActivity.class);&#10;intent.putExtra(PhotoPickerActivity.EXTRA_SHOW_CAMERA, showCamera);&#10;intent.putExtra(PhotoPickerActivity.EXTRA_SELECT_MODE, selectedMode);&#10;intent.putExtra(PhotoPickerActivity.EXTRA_MAX_MUN, maxNum);&#10;startActivityForResult(intent, PICK_PHOTO);</span><br></pre></td></tr></table></figure></p>
<p>并且重写activity的onActivityResult方法，处理返回结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override&#10;protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;&#10;    super.onActivityResult(requestCode, resultCode, data);&#10;    if(requestCode == PICK_PHOTO)&#123;&#10;        if(resultCode == RESULT_OK)&#123;&#10;             ArrayList&#60;String&#62; result = data.getStringArrayListExtra(PhotoPickerActivity.KEY_RESULT);&#10;            //do what you want to to.&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>源码地址：<a href="https://github.com/liuling07/PhotoPicker" target="_blank" rel="external">https://github.com/liuling07/PhotoPicker</a>，欢迎fork和star。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近利用闲碎的一些时间开发了一个Android库<a href="https://github.com/liuling07/PhotoPicker">PhotoPicker</a>，前面一篇文章也介绍了，<a href="http://www.liuling123.com/2015/11/android-photo-picker.html">Android高仿微信图片选择功能的PhotoPicker</a>，之前没有加入选择多张图片的功能，现在加上之后一个完整的PhotoPicker库终于算是完工了。</p>
<h2 id="u52A8_u6001_u6548_u679C_u56FE"><a href="#u52A8_u6001_u6548_u679C_u56FE" class="headerlink" title="动态效果图"></a><strong>动态效果图</strong></h2><p><img src="http://7xnqm4.com1.z0.glb.clouddn.com/photo-picker-sample.gif?watermark/1/image/aHR0cDovLzd4bnFtNC5jb20xLnowLmdsYi5jbG91ZGRuLmNvbS93YXRlcm1hcmsucG5n/dissolve/50/gravity/SouthEast" alt="Android带多选功能的PhotoPicker示例图片" title="Android带多选功能的PhotoPicker示例图片"></p>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="图片选择" scheme="http://www.liuling123.com/tags/%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9/"/>
    
      <category term="开源" scheme="http://www.liuling123.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android高仿微信图片选择功能的PhotoPicker]]></title>
    <link href="http://www.liuling123.com/2015/11/android-photo-picker.html"/>
    <id>http://www.liuling123.com/2015/11/android-photo-picker.html</id>
    <published>2015-11-15T12:25:01.000Z</published>
    <updated>2016-01-03T07:02:06.000Z</updated>
    <content type="html"><![CDATA[<p>类似于微信修改头像的功能基本上每个app都会有，以前公司开发的项目就有修改头像的功能，但是用的Android系统自带的图片选择器。用Android系统的图片选择器有个好处就是稳定，不会有什么问题。但也有它的缺点，比如不可定制，我们想要修改一下符合自己app的风格无法做到。</p>
<p>既然大部分app都要用到图片选择器，为啥我不自己写一个呢？难不成每次都用系统自带的？那显得太没水平。所以，我就有了一个自己编写一个图片选择器的想法，以后只要有项目需要这个功能，直接拿来用就行了，这多爽！</p>
<p>其实github上也有很多大牛写的图片选择开源库，虽然大家一直都推崇不要重复造轮子这个观念，但是我却不这么认为，同样是轮子，也有不同价格、不同品牌的呢，难不成有了一个制造商生产了轮子，其他厂商就没必要做了吗？所以说，重复造轮子也是有意义的，至少你知道轮子是怎么造的。</p>
<a id="more"></a>
<p>好了，闲话不多说，先看看效果图：</p>
<p>1、图片选择效果<br><img src="http://7xnqm4.com1.z0.glb.clouddn.com/photo-picker-sample01.png?watermark/1/image/aHR0cDovLzd4bnFtNC5jb20xLnowLmdsYi5jbG91ZGRuLmNvbS93YXRlcm1hcmsucG5n/dissolve/50/gravity/SouthEast" alt="Android高仿微信图片选择功能的PhotoPicker示例图片1" title="Android高仿微信图片选择功能的PhotoPicker示例图片1"></p>
<p>2、弹出文件夹选择效果：<br><img src="http://7xnqm4.com1.z0.glb.clouddn.com/photo-picker-sample02.png?watermark/1/image/aHR0cDovLzd4bnFtNC5jb20xLnowLmdsYi5jbG91ZGRuLmNvbS93YXRlcm1hcmsucG5n/dissolve/50/gravity/SouthEast" alt="Android高仿微信图片选择功能的PhotoPicker示例图片2" title="Android高仿微信图片选择功能的PhotoPicker示例图片2"></p>
<p>这里博主还是只模范微信的头像选择功能，也就是单张图片的选取。而微信发送图片消息的多张图片选择，暂时还没有做。主要是博主现在要学习C++，要快速熟悉cocos2dx的开发，没有时间去弄。后面有时间会把多图选择功能加上。</p>
<p>博主测试3部手机，vivo x3s 826张图片、联想A800 1231张、中兴V955 762张均为出现OOM，且图片加载很流畅。由于测试覆盖率不够，程序难免还会存在一些bug，如果有还望各位不吝指正，谢谢！</p>
<p>这里代码我就不贴了，需要的直接去博主github上fork源码，欢迎fork和star。</p>
<p>源码地址：<a href="https://github.com/liuling07/PhotoPicker" target="_blank" rel="external">https://github.com/liuling07/PhotoPicker</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>类似于微信修改头像的功能基本上每个app都会有，以前公司开发的项目就有修改头像的功能，但是用的Android系统自带的图片选择器。用Android系统的图片选择器有个好处就是稳定，不会有什么问题。但也有它的缺点，比如不可定制，我们想要修改一下符合自己app的风格无法做到。</p>
<p>既然大部分app都要用到图片选择器，为啥我不自己写一个呢？难不成每次都用系统自带的？那显得太没水平。所以，我就有了一个自己编写一个图片选择器的想法，以后只要有项目需要这个功能，直接拿来用就行了，这多爽！</p>
<p>其实github上也有很多大牛写的图片选择开源库，虽然大家一直都推崇不要重复造轮子这个观念，但是我却不这么认为，同样是轮子，也有不同价格、不同品牌的呢，难不成有了一个制造商生产了轮子，其他厂商就没必要做了吗？所以说，重复造轮子也是有意义的，至少你知道轮子是怎么造的。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://www.liuling123.com/tags/android/"/>
    
      <category term="图片选择" scheme="http://www.liuling123.com/tags/%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9/"/>
    
      <category term="开源" scheme="http://www.liuling123.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Android" scheme="http://www.liuling123.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[科学上网工具Lantern，轻松访问Google、Facebook等被墙网站]]></title>
    <link href="http://www.liuling123.com/2015/11/lantern.html"/>
    <id>http://www.liuling123.com/2015/11/lantern.html</id>
    <published>2015-11-11T14:13:18.000Z</published>
    <updated>2016-01-03T03:00:03.000Z</updated>
    <content type="html"><![CDATA[<p>给大家推荐一个科学上网的工具，轻松就可以访问google、facebook等被墙的网站：<a href="https://github.com/liuling07/Lantern" target="_blank" rel="external">下载Lantern</a></p>
<p>下载lantern.exe.fbd文件，将.fbd后缀去掉，双击运行即可。可能360会阻止运行，要点击允许。</p>
<p>如下图：<br><a href="http://www.liuling123.com/wp-content/uploads/2015/11/QQ图片20151111215158.png"><img src="http://www.liuling123.com/wp-content/uploads/2015/11/QQ图片20151111215158-300x129.png" alt="科学上网工具"></a></p>
<p>该工具只能用于PC端浏览器浏览被墙网站，一般查资料够用了。如果需要玩游戏或者其他用途，建议还是买VPN。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>给大家推荐一个科学上网的工具，轻松就可以访问google、facebook等被墙的网站：<a href="https://github.com/liuling07/Lantern" target="_blank" rel="external">下载Lantern</a></]]>
    </summary>
    
      <category term="科学上网" scheme="http://www.liuling123.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="其他技术" scheme="http://www.liuling123.com/categories/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MySQL导入数据报Got a packet bigger than‘max_allowed_packet’bytes错误的解决方法]]></title>
    <link href="http://www.liuling123.com/2015/11/max-allowed-packet.html"/>
    <id>http://www.liuling123.com/2015/11/max-allowed-packet.html</id>
    <published>2015-11-11T13:00:54.000Z</published>
    <updated>2016-01-03T03:00:03.000Z</updated>
    <content type="html"><![CDATA[<p>   今天将博客的数据库进行了迁移，在执行sql脚本的时候报了Got a packet bigger than‘max_allowed_packet’bytes的错误，上网搜了一下，发现是由于max_allowed_packet的值设置过小的原因，知道原因就好办了，只需要将max_allowed_packet值设置大一点就OK了。<br>   通过终端进入mysql控制台，输入如下命令可以查看max_allowed_packet值的大小。<br>   show VARIABLES like ‘%max_allowed_packet%’;<br>显示的结果为：</p>
<p>+——————–+———+<br>| Variable_name      | Value   |<br>+——————–+———+<br>| max_allowed_packet | 1048576 |<br>+——————–+———+</p>
<p>以上说明目前的配置是：1M<br>执行一下命令可以将max_allowed_packet的值设置大一点：<br>set global max_allowed_packet = 2<em>1024</em>1024*10<br>退出mysql命令行，然后重新登录。<br>show VARIABLES like ‘%max_allowed_packet%’;</p>
<p>设置完之后，再重新导入数据，OK，一切正常。</p>
<p>注意，使用这种方法，重启服务器之后又恢复默认值了。这里博主只是导数据的时候临时将其值设置大一点，导完之后尽量让其恢复原值，因为max_allowed_packet设置过大可能会导致服务器太忙来不及接收，网络差的时候也可能会出现丢包的现象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>   今天将博客的数据库进行了迁移，在执行sql脚本的时候报了Got a packet bigger than‘max_allowed_packet’bytes的错误，上网搜了一下，发现是由于max_allowed_packet的值设置过小的原因，知道原因就好办了，只需要将]]>
    </summary>
    
      <category term="mysql" scheme="http://www.liuling123.com/tags/mysql/"/>
    
      <category term="其他技术" scheme="http://www.liuling123.com/categories/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++学习随笔]]></title>
    <link href="http://www.liuling123.com/2015/11/cpp-study.html"/>
    <id>http://www.liuling123.com/2015/11/cpp-study.html</id>
    <published>2015-11-10T11:28:33.000Z</published>
    <updated>2016-01-03T07:07:40.000Z</updated>
    <content type="html"><![CDATA[<p>最近由于公司部门调整，博主被安排去做游戏开发了，使用的是cocos2d游戏引擎，开发语言为C++。所以硬着头皮边熟悉cocos2d边学C++。对于写了多年Java的来说，看C++代码很坑爹有木有。<br>但是作为Android工程师，C/C++还是有必要学的，因为Android系统源码大部分都是C写的。之前看过一段时间的Android源码，看到C++部分也是比较吃力，现在借此机会学学C++也是挺不错的。<br>下面简单记录在学习C++过程中遇到的一些不懂的东西（持续更新）。</p>
<p><strong>std::nothrow</strong></p>
<p>在内存不足时，new (std::nothrow)并不抛出异常，而是将指针置NULL。<br>如：auto layer = new (std::nothrow) FirstLayer();</p>
<p><strong>auto</strong><br>auto是C++11的新特性，自动类型推断，用于从初始化表达式中推断出变量的数据类型，有点类似于js中的弱类型var。<br><a id="more"></a><br><strong>#pragma once</strong><br>只要在头文件的最开始加入这条杂注，就能够保证头文件只被编译一次。但是是依赖编译器的，可以使用宏定义#ifndef</p>
<p><strong>#ifndef，#define，#endif</strong><br>C/C++语言中的宏定义，通过宏定义避免文件多次编译</p>
<p><strong>#if与if的区别</strong></p>
<p>#endif//与#if对应<br>作为一个编译“开关”，比如：   </p>
<p>#if(条件满足)<br>  执行代码1   </p>
<p>#else<br>  执行代码2   </p>
<p>#endif<br>假如编译时，确实满足条件，则生成的程序文件(.exe文件)中不会有执行代码2的。如果用普通if语句，生成的程序文件就会有执行代码2，这个区别看看生成文件大小就可以知道。如果你的条件在程序编译前就已经确定了，那就用#if；如果条件需要在程序运行过程中才能判断，则用if。</p>
<p><strong>static_cast</strong><br>用法：static_cast &lt; type-id &gt; ( expression )<br>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。有点类似于Java中的强制转换。</p>
<p><strong>string与int拼接</strong><br>1、stringstream拼接string与int</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stringstream ss;&#10;ss &#60;&#60; &#34;old:&#34;&#60;&#60; GameOverScene::goldNum &#60;&#60; &#34;,distance:&#34; &#60;&#60; GameOverScene::distance;&#10;LabelTTF* goldAndDistanceLabel = LabelTTF::create(ss.str(), &#34;Arial&#34;, 30);</span><br></pre></td></tr></table></figure>
<p>2、sprintf函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char countBuf[16] = &#34;&#34;;&#10;sprintf(countBuf, &#34;distance:%d&#34;, mDistance);</span><br></pre></td></tr></table></figure>
<p>3、std::to_string函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s = &#34;run0&#34; + std::to_string(i) + &#34;.png&#34;;</span><br></pre></td></tr></table></figure>
<p>安卓没有to_string这个函数，eclipse中编译出错，为了跨平台，尽量使用stringstream或者sprintf</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近由于公司部门调整，博主被安排去做游戏开发了，使用的是cocos2d游戏引擎，开发语言为C++。所以硬着头皮边熟悉cocos2d边学C++。对于写了多年Java的来说，看C++代码很坑爹有木有。<br>但是作为Android工程师，C/C++还是有必要学的，因为Android系统源码大部分都是C写的。之前看过一段时间的Android源码，看到C++部分也是比较吃力，现在借此机会学学C++也是挺不错的。<br>下面简单记录在学习C++过程中遇到的一些不懂的东西（持续更新）。</p>
<p><strong>std::nothrow</strong></p>
<p>在内存不足时，new (std::nothrow)并不抛出异常，而是将指针置NULL。<br>如：auto layer = new (std::nothrow) FirstLayer();</p>
<p><strong>auto</strong><br>auto是C++11的新特性，自动类型推断，用于从初始化表达式中推断出变量的数据类型，有点类似于js中的弱类型var。<br>]]>
    
    </summary>
    
      <category term="c++" scheme="http://www.liuling123.com/tags/c/"/>
    
      <category term="其他技术" scheme="http://www.liuling123.com/categories/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
